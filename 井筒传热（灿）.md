# 热码（灿）**

D:\传热资料\theraml_data\thermalModel\cpp\Temperature
// WellboreHeatTransfer.cpp
//井筒传热部分



### **源码：**

```c++
// WellboreHeatTransfer.cpp

#include "Temperature/WellboreHeatTransfer.h"
#include <cmath>
#include <algorithm> // for swap() function
#include <functional>
#include"libInterpolate/Interpolate.hpp"
/*
void HeatTransfer::TemperatureResultsRemapping(const VarList& h, const std::vector<double>& preMD,
    const std::vector<double>& preTp, const std::vector<double>& preTa, const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, const std::vector<std::vector<double>>& prePpore)
{
    Radius.clear();

    Ppore.clear();
    MD.clear();

    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
    size_t nz = preTf.size();
    //int nz = (int)XYZ_Series.size();
    try
    {

        
        /*
        const double TOL = 1.0e-8;
        double rw = XYZ_Series.front().d / 2.0;
        if (fabs(h.eps - 1.0) > TOL)
        {
            nr = (int)ceil(log(1.0 - (1.0 - h.eps) * (h.re - rw) / h.dr) / log(h.eps)) + 1;
        }
        else
        {
            nr = (int)ceil((h.re - rw) / h.dr) + 1;
        }
        

        // STEP1:
        // initial raduis profile.
        //int pz = int(h.dzOut / h.dz); // get integer part
        //int pr = int(h.drOut / h.dr); // get integer part
        int pz = int(30 / 30); // get integer part
        int pr = int(0.06 / 0.06); // get integer part

        //int mr = (int)ceil(double(nr - 1) / double(pr)) + 1; // equal to "nr" ,if pr=1.

        size_t i = 0, i0 = 0;
        Radius = preRadius;
        //while (i < nz)
        //{
            //preTf[i]
            //int j1 = 0, j0 = 0;
            // dimensionless radius
            //std::vector<double> rad_dims;
            //rad_dims.resize(mr);
            /*
            // tural radius of curt component
            std::vector<double> rad_;
            while (j0 < nr - 1)
            {
                double eps1;
                if (fabs(h.eps - 1.0) <= TOL)
                    eps1 = j0;
                else
                    eps1 = (1.0 - pow(h.eps, j0)) / (1.0 - h.eps);
                rad_dims[j1] = (XYZ_Series[i0].d / 2.0 + eps1 * h.dr) / (XYZ_Series[i0].d / 2.0);

                j0 += pr;
                ++j1;
            }
            // add last data point in radius dimension
            rad_dims[mr - 1] = h.re / (XYZ_Series[i0].d / 2.0);

            // set radius value with dimension value
            for (size_t i = 0; i < rad_dims.size(); i++)
                rad_.push_back(rad_dims[i] * (XYZ_Series[i0].d / 2.0));
            Radius.push_back(rad_);
            i0 += pz;
            ++i1;
            
       // }

        // STEP2:
        // initial pore pressure profile.
        Ppore = prePpore;
        
        for (int i = 0; i < nz; ++i)
        {
            std::vector<double> Pp_;

            //Pp(i, 0, 0) = Pa_Series[i];
            Pp_.push_back(Pa_Series[i]);// set pore pressure value along wellbore/annulus

            // get far field property.
            double tmp = XYZ_Series[i].formInfo.back()->Ppore * XYZ_Series[i].z;

            for (size_t j = 1; j < Radius[i].size(); j++)
                Pp_.push_back(tmp);
            Ppore.push_back(Pp_);

            MD.push_back(XYZ_Series[i].md);
        }
        

        // STEP3:
        // if previous heat profile "NOT" valid.
        if (preTp.size() < 1 || preTa.size() != preTf.size())
        {
            for (int i = 0; i < nz; ++i)
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < 273.15 + 4)
                {
                    tmp = 273.15 + 4.0;
                }
                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                std::vector<double> Tf_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                    Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
                // std::cout << "check line 104, indx i: " << i << "\t currMD: " << XYZ_Series[i].md << " \tTp:" << Tp(i, 0) << "\tsTa: " << Ta(i, 0) << "\tsTf: " << Tf(i, 0) << std::endl;
            }            
            // MUST!
            return;
        }

        // STEP4:
        // else previous heat profile "IS" valid.
        // if previous Tp profile contian -999.25, means tripping in
        // use annulus's temperature replace of pipe's component.
        std::vector<double> perTp_refr; // refreshed perTp profile
        for (size_t i = 0; i < preTp.size(); i++)
        {
            if (preTp[i] < 0)
                perTp_refr.push_back(preTa[i]);
            else
                perTp_refr.push_back(preTp[i]);
        }

        // STEP5:
        double curtMD;
        int tmp = 0;

        for (size_t i = 0; i < XYZ_Series.size(); i++)
        {
            curtMD = XYZ_Series[i].md;

            // 1. case: current well component "BEFORE" previous' component
            if (curtMD < preMD.front())
            {
                Tpipe.push_back(perTp_refr.front());
                Tannulus.push_back(preTa.front());

                // set current formation's temperature profile
                std::vector<double> Tf_;
                //for (size_t j = 1; j < Radius[i].size(); j++)
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < preRadius[0].front())
                    {
                        Tf_ .push_back(preTf[0].front());
                    }
                    else if (curtR > preRadius[0].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < 273.15 + 4)
                        {
                            tmp = 273.15 + 4.0;
                        }
                        Tf_.push_back(tmp);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, preRadius[0], preTf[0]));
                    }
                }
                Tformation.push_back(Tf_);
            }
            // 2. case: current well component "AFTER" previous' component
            else if (curtMD > preMD.back())
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < 273.15 + 4)
                    tmp = 273.15 + 4.0;

                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                // set current formation's temperature profile
                std::vector<double> Tf_;

                for (size_t j = 0; j < Radius[i].size(); j++)
                   Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
            }
            // 3. case: current well component "BELONG TO" previous' component
            else
            {
                Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
                Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));

                // 3.a. set "preIndx" and suitale radius/ Tf profile
                // note: first, need set prevoius formation temperature profile to current compoent
                // then, special for curtR 
                int preIndx = -99;

                std::vector<double> raduis_suit4CurtMDComp;
                std::vector<double> Tf_suit4CurtMDComp;
                for (size_t m = 1; m < preMD.size(); m++)
                {
                    if (curtMD < preMD[m])
                    {
                        preIndx = m;
                        break;
                    }
                }

                // 3.b. if "NO" get indx, mean: curt md is buttom.
                if (preIndx < 0)
                {
                    raduis_suit4CurtMDComp = preRadius.back();
                    Tf_suit4CurtMDComp = preTf.back();
                }
                else
                {
                    for (size_t j = 0; j < preRadius[preIndx].size(); j++)
                    {
                        std::vector<double> md_suit4CurtComp_2Doit;
                        std::vector<double> raduis_suit4CurtComp_2Doit;
                        std::vector<double> Tf_suit4CurtComp_2Doit;

                        md_suit4CurtComp_2Doit.push_back(preMD[preIndx-1]);
                        md_suit4CurtComp_2Doit.push_back(preMD[preIndx]);

                        raduis_suit4CurtComp_2Doit.push_back(preRadius[preIndx - 1][j]);
                        raduis_suit4CurtComp_2Doit.push_back(preRadius[preIndx][j]);
                        raduis_suit4CurtMDComp.push_back(linerInterpolation4Vector(curtMD, md_suit4CurtComp_2Doit, raduis_suit4CurtComp_2Doit));

                        Tf_suit4CurtComp_2Doit.push_back(preTf[preIndx - 1][j]);
                        Tf_suit4CurtComp_2Doit.push_back(preTf[preIndx][j]);
                        Tf_suit4CurtMDComp.push_back(linerInterpolation4Vector(curtMD, md_suit4CurtComp_2Doit, Tf_suit4CurtComp_2Doit));
                    }
                }

                // 3.c. set current formation's temperature profile
                std::vector<double> Tf_;

                //std::cout << "tmp+1: " << tmp << std::endl;
                //tmp++;
                //if(tmp==335)
                //    std::cout << "tmp+0: " << tmp << std::endl;

                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < raduis_suit4CurtMDComp.front())
                    {
                        Tf_.push_back(Tf_suit4CurtMDComp.front());
                    }
                    else if (curtR > raduis_suit4CurtMDComp.back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < 273.15 + 4)
                        {
                            tmp = 273.15 + 4.0;
                        }
                        Tf_.push_back(tmp);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, raduis_suit4CurtMDComp, Tf_suit4CurtMDComp));
                    }
                }
                Tformation.push_back(Tf_);

                //std::cout << "tmp+2: " << tmp << std::endl;
            }
        }
        std::cout << "tmp end: " << tmp << std::endl;
    }
    catch (const std::exception& e)
    {
        std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
        throw std::runtime_error(error);
    }
}
*/


void HeatTransfer::TemperatureResultsRemapping(const VarList& h, const std::vector<double>& preMD,
    const std::vector<double>& preTp, const std::vector<double>& preTa, const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, const std::vector<std::vector<double>>& prePpore)
{
    Radius.clear();
    Ppore.clear();
    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
    size_t nz = preTf.size();
    Radius = preRadius;

     try
     {
        // STEP2: pore pressure profile.
       // Ppore = prePpore;
        // STEP3:
        // if previous heat profile "NOT" valid.
        if (preTp.size() < 1 || preTa.size() != preTf.size())
        {
            for (int i = 0; i < nz; ++i)
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        +std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }
                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                std::vector<double> Tf_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                    Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
                // std::cout << "check line 104, indx i: " << i << "\t currMD: " << XYZ_Series[i].md << " \tTp:" << Tp(i, 0) << "\tsTa: " << Ta(i, 0) << "\tsTf: " << Tf(i, 0) << std::endl;
            }
        }

        // STEP 4:
        // else previous heat profile "IS" valid.
        // if previous Tp profile contian -999.25, means tripping in
        // use annulus's temperature replace of pipe's component.
        std::vector<double> perTp_refr; // refreshed perTp profile
        for (size_t i = 0; i < preTp.size(); i++)
        {
            if (preTp[i] < 0)
                perTp_refr.push_back(preTa[i]);
            else
                perTp_refr.push_back(preTp[i]);
        }
        // STEP 5:
        double curtMD;
        int tmp = 0;

        _2D::BilinearInterpolator<double> interp2DTf;
        _2D::BilinearInterpolator<double> interp2DPp;

        //construct 2D interploation data format
        std::vector<double> preMD2D;
        std::vector<double> preRadius2D;
        std::vector<double> preTf2D;
        std::vector<double> prePore2D;
        for (int i=0;i<preMD.size();i++)
        {
            for (int j=0;j<preRadius[i].size();j++)
            {
                preMD2D.push_back(preMD[i]);
                preRadius2D.push_back(preRadius[i][j]);
                preTf2D.push_back(preTf[i][j]);
                prePore2D.push_back(prePpore[i][j]);
            }
        }
        interp2DTf.setData(preMD2D, preRadius2D, preTf2D);
        interp2DPp.setData(preMD2D, preRadius2D, prePore2D);


        for (size_t i = 0; i < XYZ_Series.size(); i++)
        {
            curtMD = XYZ_Series[i].md;

            // 1. case: current well component "BEFORE" previous' component
            if (curtMD < preMD.front())
            {
                Tpipe.push_back(perTp_refr.front());
                Tannulus.push_back(preTa.front());

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < preRadius[0].front())
                    {
                        Tf_.push_back(preTf[0].front());
                        Pp_.push_back(prePpore[0].front());
                    }
                    else if (curtR > preRadius[0].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < -273)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, preRadius[0], preTf[0]));
                        Pp_.push_back(linerInterpolation4Vector(curtR, preRadius[0], prePpore[0]));
                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
            // 2. case: current well component "AFTER" previous' component
            else if (curtMD > preMD.back())
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }

                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;

                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    Tf_.push_back(tmp);
                    Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                }
                  
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);

            }
            // 3. case: current well component "BELONG TO" previous' component
            else
            {
                Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
                Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));

                // 3.a. set "preIndx" and suitale radius/ Tf profile
                // note: first, need set prevoius formation temperature profile to current compoent
                // then, special for curtR

                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                   // std::cout << i << ", " << j << std::endl;

                    double curtR = Radius[i][j];
                    if (curtR < preRadius[i].front())
                    {
                        Tf_.push_back(preTf[i].front());
                        Pp_.push_back(prePpore[i].front());
                    }
                    else if (curtR > preRadius[i].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp <-273.00)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);

                    }
                    else
                    {
                        Tf_.push_back(interp2DTf(curtMD, curtR));
                        Pp_.push_back(interp2DPp(curtMD, curtR));

                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
        }
       // std::cout << "tmp end: " << tmp << std::endl;
    }
    catch (const std::exception& e)
    {
        std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
        throw std::runtime_error(error);
    }
}


void HeatTransfer::HeatTransferCal2D(const VarList& h, const std::vector<double> & preMD, 
    const std::vector<double> & preTp, const std::vector<double> & preTa, const std::vector<std::vector<double>> & preRadius,
    const std::vector<std::vector<double>> &preTf, const std::vector<std::vector<double>>& prePpore)
{
    const double PI = 3.14159265358979;
    const double TOL = 1.0e-8;

    // mechanical heat rate generated
    std::vector<double> qs = HeatByDragForce(h);
    double qb = HeatByDrillbit(h);

    //这又没有考虑钻头摩擦生热，2023-07-23
    qb = 0; //temp ignore bit
    qs.back() += qb; // add heat at drillbit
    //qs.clear();
    //----------------------------------------------------------------------------------------------------------------//
  
    // calculate the number of nodes in each dimension for calculation
    int nz, nt;//nodes of z axial ,time
    nz = (int)XYZ_Series.size();
    // assuming that (re - rw) is constant
    double rw = XYZ_Series.front().d / 2.0;
 
    //------------- remapping previous results to current mesh --------------
    //     Ppore, Radius, Tpipe, Tannulus, Tformation
    TemperatureResultsRemapping(h, preMD, preTp, preTa, preRadius, preTf,prePpore);

    /**************************************************************************
    * Main Computation Zone.
    * Description: Explicit method, with upwind scheme.
    * Ref: Master's thesis of Duc A. Nguyen.
    * Equ: 4.1.
    **************************************************************************/
    //int n2 = pt, n3 = 1; // for main data matrices
    double ds;
    int nr;
        /**************************************************************************
        * Description: Formula of calculating pore pressure profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/
    int fmaIndex; 

        //----------------------------------------------------------------------------------------//
        /**************************************************************************
        * Description: Formula of calculating drillpipe fluid temperature profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/
      
        Tpipe[0] = h.Tin;

        // main profile
        for (int i = 1; i < nz; ++i)
        {
            ds = XYZ_Series[i].md - XYZ_Series[i - 1].md;
            double B1, B2;
            //20201011DEBUG via kxpt@me.com
            // overall heat transfer coefficient between drillpipe and annulus fluid
            double Uap = XYZ_Series[i].fluidAnn.hc;
            if (XYZ_Series[i].pOR > 0.0)
            {
                Uap = 1.0 / (XYZ_Series[i].pOR / (XYZ_Series[i].pIR * XYZ_Series[i].fluidPipe.hc) + 
                    XYZ_Series[i].pOR * log(XYZ_Series[i].pOR / XYZ_Series[i].pIR) / XYZ_Series[i].pCond + 1.0 / XYZ_Series[i].fluidAnn.hc);
            }
            B1 = XYZ_Series[i].fluidPipe.flDens * XYZ_Series[i].fluidPipe.flCp * XYZ_Series[i].pOR / (2.0 * Uap);
            B2 = -h.Q * XYZ_Series[i].fluidPipe.flDens * XYZ_Series[i].fluidPipe.flCp / (2.0 * PI * XYZ_Series[i].pOR * Uap);

            double Cp1, Cp2, Cp3, Cp4;
            Cp1 = 1.0 / B1;
            Cp2 = -B2 * h.dt / ds;
            Cp3 = B1 + B2 * h.dt / ds - h.dt;
            Cp4 = h.dt;

            // check if curt Q in is TOO Giant
            if (Cp3 < 0.0)
            {
                Cp2 = B1 - h.dt;
                Cp3 = 0.0;
            }

            Tpipe[i] = Cp1 * (Cp2 * Tpipe[i-1] + Cp3 * Tpipe[i] + Cp4 * Tannulus[i]);
           // std::cout << i << ", " << Tp(i, n1) << std::endl;
        }

        /**************************************************************************
        * Description: Formula of calculating annulus fluid temperature profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/
        // boundary condition (at total depth, Tp = Ta)
        Tannulus[nz - 1] = Tpipe[nz - 1];

        // main profile
        for (int i = nz - 2; i >= 0; --i)
        {
            rw = XYZ_Series[i].d / 2;
            ds = XYZ_Series[i + 1].md - XYZ_Series[i].md;

            double A1, A2, A3, A4;
            //20201011DEBUG via kxpt@me.com
            // overall heat transfer coefficient between drillpipe and annulus fluid
            double Uap = XYZ_Series[i].fluidAnn.hc;
            if (XYZ_Series[i].pOR > 0.0)
            {
                Uap = 1.0 / (XYZ_Series[i].pOR / (XYZ_Series[i].pIR * XYZ_Series[i].fluidPipe.hc) + XYZ_Series[i].pOR * log(XYZ_Series[i].pOR / XYZ_Series[i].pIR) / XYZ_Series[i].pCond + 1.0 / XYZ_Series[i].fluidAnn.hc);
            }
            A1 = XYZ_Series[i].fluidAnn.flDens * XYZ_Series[i].fluidAnn.flCp * (pow(rw, 2) - pow(XYZ_Series[i].pOR, 2)) / (2.0 * rw * XYZ_Series[i].fluidAnn.hc);
            A2 = h.Q * XYZ_Series[i].fluidAnn.flDens * XYZ_Series[i].fluidAnn.flCp / (2.0 * PI * rw * XYZ_Series[i].fluidAnn.hc);
            A3 = XYZ_Series[i].pOR * Uap / (rw * XYZ_Series[i].fluidAnn.hc);
            A4 = qs[i] / (2 * PI * rw * XYZ_Series[i].fluidAnn.hc * ds);


            double Ca1, Ca2, Ca3, Ca4, Ca5, Ca6;
            Ca1 = 1.0 / A1;
            Ca2 = A1 - A2 * h.dt / ds - A3 * h.dt - h.dt;
            Ca3 = A2 * h.dt / ds;
            Ca4 = A3 * h.dt;
            Ca5 = h.dt;
            Ca6 = A4 * h.dt;

            // check if curt Q in is TOO Giant
            if (Ca2 < 0.0)
            {
                Ca3 = A1 - A3 * h.dt - h.dt;
                Ca2 = 0.0;
            }
            Tannulus[i] = Ca1 * (Ca2 * Tannulus[i]+ Ca3 * Tannulus[i+1] + Ca4 * Tpipe[i] + Ca5 * Tformation[i][0] + Ca6);
           // std::cout << i << ", " << Ta(i, n1) << std::endl;

        }

        /**************************************************************************
        * Description: Formula of calculating formation temperature profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/

        // boundary condition at surface
        // formation temperature node at surface and wellbore wall
        double Cf1, Cf2, Cf3, Cf4, Cf5;
        Cf1 = 4.0 * h.dt / (h.dr * ds * XYZ_Series[0].formInfo[0]->fDens * XYZ_Series[0].formInfo[0]->fCp);
        Cf2 = h.dr * ds * XYZ_Series[0].formInfo[0]->fDens * XYZ_Series[0].formInfo[0]->fCp / 
            (4.0 * h.dt) - h.dr * h.surfHTC / 2.0 - ds * XYZ_Series[0].formInfo[0]->fCond / h.dr - 
            h.dr * XYZ_Series[0].formInfo[0]->fCond / (2.0 * ds);
        Cf3 = ds * XYZ_Series[0].formInfo[0]->fCond / (2.0 * h.dr);
        Cf4 = h.dr * XYZ_Series[0].formInfo[0]->fCond / (2.0 * ds);
        Cf5 = h.dr * h.surfHTC / 2.0;

        //Tf(0, 0, n1) = Cf1 * (Cf2 * Tf(0, 0, n0) + Cf3 * (Tf(0, 1, n0) + Ta(0, n0)) + Cf4 * Tf(1, 0, n0) + Cf5 * h.surfTemp);
        //Tf(0, n1) = Cf1 * (Cf2 * Tf(0, n0) + Cf3 * (Tf(0, n0) + Ta(0, n0)) + Cf4 * Tf(1, n0) + Cf5 * h.surfTemp);
        Tformation[0][0]= Cf1 * (Cf2 * Tformation[0][0] + Cf3 * (Tformation[0][0] + Tannulus[0]) + Cf4 * Tformation[1][0] + Cf5 * h.surfTemp);

        // main profile at surface
        nr = Ppore[0].size();
        for (int j = 1; j < nr - 1; ++j)
        {
            double Cf1, Cf2, Cf3, Cf4, Cf5, Cf6;
            fmaIndex = 0;
            while (fmaIndex < XYZ_Series[0].formInfo.size() - 1)
            {
                if (Radius[0][j] > XYZ_Series[0].formInfo[fmaIndex + 1]->innerRadius)
                {
                    fmaIndex++;
                }
            }
            Cf1 = 2.0 * h.dt / (h.dr * ds * XYZ_Series[0].formInfo[fmaIndex]->fDens * XYZ_Series[0].formInfo[fmaIndex]->fCp);
            Cf2 = h.dr * ds * XYZ_Series[0].formInfo[fmaIndex]->fDens * XYZ_Series[0].formInfo[fmaIndex]->fCp / (2.0 * h.dt) - pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * h.surfHTC / 2.0
                - pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * ds) - ds * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * h.dr) * (1.0 / pow(h.eps, j - 1) + 1.0 / pow(h.eps, j));
            Cf3 = ds * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * pow(h.eps, j - 1) * h.dr);
            Cf4 = ds * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * pow(h.eps, j) * h.dr);
            Cf5 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * ds);
            Cf6 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * h.surfHTC / 2.0;

            //Tf(0, j) = Cf1 * (Cf2 * Tf(0, j) + Cf3 * Tf(0, j - 1) + Cf4 * Tf(0, j + 1) + Cf5 * Tf(1, j) + Cf6 * h.surfTemp);
            Tformation[0][j] = Cf1 * (Cf2 * Tformation[0][j] + Cf3 * Tformation[0][j-1] + Cf4 * Tformation[0][j+1] + Cf5 * Tformation[1][j] + Cf6 * h.surfTemp);
        }

        // formation temperature node at surface and far field
        Tformation[0][nr - 1] = Tformation[0][nr - 2];
        
        //--------------------------------------------------------------------//

        // main profile
        for (int i = 1; i < nz - 1; ++i)
        {
            // boundary condition at borehole wall
            double Cf1, Cf2, Cf3, Cf4, Cf5;
            Cf1 = 2.0 * h.dt / (h.dr * ds * XYZ_Series[i].formInfo[0]->fDens * XYZ_Series[i].formInfo[0]->fCp);
            Cf2 = h.dr * ds * XYZ_Series[i].formInfo[0]->fDens * XYZ_Series[i].formInfo[0]->fCp / (2.0 * h.dt) - 
                ds * XYZ_Series[i].fluidAnn.hc - ds * XYZ_Series[i].formInfo[0]->fCond / h.dr - h.dr * XYZ_Series[i].formInfo[0]->fCond / ds;
            Cf3 = h.dr * XYZ_Series[i].formInfo[0]->fCond / (2.0 * ds);
            Cf4 = ds * XYZ_Series[i].formInfo[0]->fCond / h.dr;
            Cf5 = ds * XYZ_Series[i].fluidAnn.hc;

            Tformation[i][0] = Cf1 * (Cf2 * Tformation[i][0] + Cf3 * (Tformation[i-1][0] + Tformation[i + 1][0]) + Cf4 * Tformation[i][1] + Cf5 * Tannulus[i]);

            // main profile
            rw = XYZ_Series[i].d / 2;
            if (i == 0)
                ds = XYZ_Series[1].md - XYZ_Series[0].md;
            else
                ds = XYZ_Series[i].md - XYZ_Series[i - 1].md;

            nr = Ppore[i].size();

            for (int j = 1; j < nr - 1; ++j)
            {
                double eps1;
                if (fabs(h.eps - 1.0) <= TOL)
                {
                    eps1 = j;
                }                    
                else
                {
                    eps1 = (1.0 - pow(h.eps, j)) / (1.0 - h.eps);
                }
                   
                fmaIndex = 0;
                while (fmaIndex < XYZ_Series[i].formInfo.size() - 1)
                {
                    if (Radius[i][j] > XYZ_Series[i].formInfo[fmaIndex + 1]->innerRadius)
                    {
                        fmaIndex++;
                    }

                }
                //20201011 DEBUG via kxpt@me.com
                double alphaf = XYZ_Series[i].formInfo[fmaIndex]->fCond / (XYZ_Series[i].formInfo[fmaIndex]->fDens * XYZ_Series[i].formInfo[fmaIndex]->fCp); // formation thermal diffusivity
                double Cf1, Cf2, Cf3, Cf4, Cf5, Cf6, Cf7;
                Cf1 = alphaf * h.dt / pow(h.dr, 2);
                Cf2 = 1.0 / pow(h.eps, 2 * j - 2) + (1.0 - h.eps) / (pow(h.eps, 2 * j - 1) * (1.0 + h.eps))
                    - 1.0 / (((rw / h.dr) + eps1) * (1.0 + h.eps) * pow(h.eps, j - 1));
                Cf3 = pow(h.dr, 2) / (alphaf * h.dt) - (1.0 + pow(h.eps, 2)) / pow(h.eps, 2 * j) - 2 * pow(h.dr, 2) / pow(ds, 2);
                Cf4 = 1.0 / pow(h.eps, 2 * j) - (1.0 - h.eps) / (pow(h.eps, 2 * j - 1) * (1.0 + h.eps))
                    + 1.0 / (((rw / h.dr) + eps1) * (1.0 + h.eps) * pow(h.eps, j - 1));
                Cf5 = pow(h.dr / ds, 2);
                Cf6 = pow(h.dr / ds, 2);
                Cf7 = (XYZ_Series[i].formInfo[fmaIndex]->pflDens * XYZ_Series[i].formInfo[fmaIndex]->pflCp / (XYZ_Series[i].formInfo[fmaIndex]->fDens *
                    XYZ_Series[i].formInfo[fmaIndex]->fCp) * XYZ_Series[i].formInfo[fmaIndex]->fPerm / (XYZ_Series[i].formInfo[fmaIndex]->pflVisc * XYZ_Series[i].formInfo[fmaIndex]->fPor))
                    / (alphaf * pow(1.0 + h.eps, 2) * pow(h.eps, 2 * j - 2));

                Tformation[i][j] = Cf1 * (Cf2 * Tformation[i][j-1] + Cf3 * Tformation[i][j] + Cf4 * Tformation[i][j+1]
                    + Cf5 * Tformation[i-1][j] + Cf6 * Tformation[i+1][j])
                    + Cf7 * (Ppore[i][j + 1] - Ppore[i][j - 1]) * (Tformation[i][j+1] - Tformation[i][j-1]);
            }

            // boundary condition at far field
            Tformation[i][nr - 1] = Tformation[i][nr - 2];
        }

        //--------------------------------------------------------------------//

        // boundary condition at bottomhole
        // formation temperature node at bottomhole and wellbore wall
        //double Tfbh = h.surfTemp + XYZ_Series[nz - 1].formInfo[0]->fThermal * XYZ_Series[nz - 1].z; // not really accurate, should use drill ahead TVD
        double Tfbh = XYZ_Series[nz - 1].formInfo[0]->fTemp;

        // double Cf1, Cf2, Cf3, Cf4, Cf5;
        Cf1 = 4.0 * h.dt / (h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp);
        Cf2 = h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp / (4.0 * h.dt) - 
            ds * XYZ_Series[nz - 1].fluidAnn.hc / 2.0 - ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * h.dr) - h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / ds;
        Cf3 = h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * ds);
        Cf4 = ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * h.dr);
        Cf5 = ds * XYZ_Series[nz - 1].fluidAnn.hc / 2.0;

        Tformation[nz - 1][0] = Cf1 * (Cf2 * Tformation[nz - 1][0] + Cf3 * (Tformation[nz - 2][0] + Tfbh) + Cf4 * Tformation[nz - 1][0] + Cf5 * Tannulus[nz - 1]);

        
        // main profile at bottomhole
        nr = Ppore.back().size();

        for (int j = 1; j < nr - 1; ++j)
        {
            double Cf1, Cf2, Cf3, Cf4, Cf5, Cf6;
            Cf1 = 2.0 * h.dt / (h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp);
            Cf2 = h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp / (2.0 * h.dt) - pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / ds
                - ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * h.dr) * (1.0 / pow(h.eps, j - 1) + 1.0 / pow(h.eps, j));
            Cf3 = ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * pow(h.eps, j - 1) * h.dr);
            Cf4 = ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * pow(h.eps, j) * h.dr);
            Cf5 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * ds);
            Cf6 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * ds);

            Tformation[nz - 1][j] = Cf1 * (Cf2 * Tformation[nz - 1][j] + Cf3 * Tformation[nz - 1][j-1] + Cf4 * Tformation[nz - 1][j+1] + Cf5 * Tformation[nz - 2][j] + Cf6 * Tfbh);
        }

        // formation temperature node at bottomhole and far field
        Tformation[nz - 1][nr - 1] = Tformation[nz - 1][nr - 2];
}

/**************************************************************************
* Description: Formula of evaluation of frictional heat sources.
* Ref: Master's thesis of Duc A. Nguyen.
* Equ: 2.55- 2.57.
**************************************************************************/
std::vector<double> HeatTransfer::HeatByDragForce(const VarList& h)
{
    const double PI = 3.14159265358979;
    const double TOL = 1.0e-8;

    std::vector<double> qd;

    int tem = 0;
    for (std::vector<DragTorqueData>::const_iterator i = DT_Series.begin(); (i + 1) != DT_Series.end(); ++i, ++tem)
    {
        double ds = (i + 1)->md - i->md;
        double qs;
        //First determine whether there is a drill string at the current step
        if (XYZ_Series[tem].pOR > 0.0)
        {
            if (h.RPM <= TOL) // sliding mode
            {
                qs = h.mu * i->Wc * h.ROP * ds;
            }
            else // rotating mode
            {
                qs = h.mu * i->Wc * XYZ_Series[tem].pOR * 2.0 * PI * h.RPM * ds;
            }
        }
        else
        {
            qs = 0.0;
        }
        //这不是没考虑该项热源项嘛？ 2023-07-23
        qs = 0.0; //temperaturaly ingore pipe frictions
        if (std::isnormal(qs))
        {
            qd.push_back(qs);
        }
        else
        {
            qd.push_back(0.0);
        }
    }

    return qd;
}

double HeatTransfer::HeatByDrillbit(const VarList& h)
{
    const double PI = 3.14159265358979;
    double qb = (1.0 - h.bitEff) * (h.WOB * h.ROP + 2.0 * PI * h.RPM * DT_Series.back().Mt);
    qb = std::max(0.0, qb);
    if (std::isinf(qb) || std::isnan(qb))
    {
        qb = 0.0;
    }
    return qb;
}
```







### **head：**

```c++
#include "Temperature/WellboreHeatTransfer.h"
#include <cmath>
#include <algorithm> // for swap() function
#include <functional>
#include"libInterpolate/Interpolate.hpp"
```

#include"libInterpolate/Interpolate.hpp":是一个仅限 C++ 头文件的库，旨在实现高效、轻松的数据插值。
`libInterpolate` is a C++ header-only library designed for efficient and easy interpolation of data. The code snippet provided:

```cpp
#include "libInterpolate/Interpolate.hpp"
```

is including the `libInterpolate` header file into a C++ project, allowing access to its interpolation features. Here's a breakdown of its significance and how it is typically used:

### Purpose of the Library:
`libInterpolate` provides various interpolation methods that can be applied to discrete data points. Interpolation is a process of estimating unknown values that fall within the range of a discrete set of known data points. Common applications include numerical analysis, scientific computing, and any domain where approximating values between known data is necessary.

### Available Interpolation Methods:
The library includes a variety of interpolation techniques, such as:
1. **Linear Interpolation:** Straight-line interpolation between known data points.
2. **Polynomial Interpolation:** Fits a polynomial curve through the points.
3. **Spline Interpolation:** More advanced, providing smooth curves that better fit the data (e.g., cubic spline).
4. **Barycentric Interpolation:** A method of polynomial interpolation that is efficient and stable.

### Example Usage:

An example of how `libInterpolate` can be used is shown below:

```cpp
#include "libInterpolate/Interpolate.hpp"
#include <vector>
#include <iostream>

int main() {
    std::vector<double> xData = {0.0, 1.0, 2.0, 3.0};  // Known x-values
    std::vector<double> yData = {0.0, 1.0, 4.0, 9.0};  // Known y-values (y = x^2)

    // Create an interpolator instance
    _1D::LinearInterpolator<double> interp;

    // Set the data for interpolation
    interp.setData(xData, yData);

    // Perform interpolation
    double y = interp(1.5);  // Interpolates at x = 1.5

    std::cout << "Interpolated value at x=1.5: " << y << std::endl;

    return 0;
}
```

### Key Features:
- **Header-only:** This means no need to link against a compiled library; you only need the header files.
- **Templated:** Works with various data types (e.g., `double`, `float`).
- **1D Interpolation:** The library is optimized for one-dimensional interpolation, which is the most common use case.

### Conclusion:
By including `libInterpolate/Interpolate.hpp`, you gain access to efficient interpolation methods in your C++ program, making it easier to estimate intermediate values between known data points. You would typically use this library in applications where smooth transitions between data points are critical, such as simulations, numerical methods, and data analysis tasks.

```c++
void HeatTransfer::TemperatureResultsRemapping(const VarList& h, const std::vector<double>& preMD,
    const std::vector<double>& preTp, const std::vector<double>& preTa, const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, const std::vector<std::vector<double>>& prePpore)
//温度结果重新映射TemperatureResultsRemapping



{
    Radius.clear();
    Ppore.clear();
    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
    size_t nz = preTf.size();
    Radius = preRadius;

     try
     {
        // STEP2: pore pressure profile.
       // Ppore = prePpore;
        // STEP3:
        // if previous heat profile "NOT" valid.
        if (preTp.size() < 1 || preTa.size() != preTf.size())
        {
            for (int i = 0; i < nz; ++i)
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        +std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }
                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                std::vector<double> Tf_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                    Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
                // std::cout << "check line 104, indx i: " << i << "\t currMD: " << XYZ_Series[i].md << " \tTp:" << Tp(i, 0) << "\tsTa: " << Ta(i, 0) << "\tsTf: " << Tf(i, 0) << std::endl;
            }
        }

        // STEP 4:
        // else previous heat profile "IS" valid.
        // if previous Tp profile contian -999.25, means tripping in
        // use annulus's temperature replace of pipe's component.
        std::vector<double> perTp_refr; // refreshed perTp profile
        for (size_t i = 0; i < preTp.size(); i++)
        {
            if (preTp[i] < 0)
                perTp_refr.push_back(preTa[i]);
            else
                perTp_refr.push_back(preTp[i]);
        }
        // STEP 5:
        double curtMD;
        int tmp = 0;

        _2D::BilinearInterpolator<double> interp2DTf;
        _2D::BilinearInterpolator<double> interp2DPp;

        //construct 2D interploation data format
        std::vector<double> preMD2D;
        std::vector<double> preRadius2D;
        std::vector<double> preTf2D;
        std::vector<double> prePore2D;
        for (int i=0;i<preMD.size();i++)
        {
            for (int j=0;j<preRadius[i].size();j++)
            {
                preMD2D.push_back(preMD[i]);
                preRadius2D.push_back(preRadius[i][j]);
                preTf2D.push_back(preTf[i][j]);
                prePore2D.push_back(prePpore[i][j]);
            }
        }
        interp2DTf.setData(preMD2D, preRadius2D, preTf2D);
        interp2DPp.setData(preMD2D, preRadius2D, prePore2D);


        for (size_t i = 0; i < XYZ_Series.size(); i++)
        {
            curtMD = XYZ_Series[i].md;

            // 1. case: current well component "BEFORE" previous' component
            if (curtMD < preMD.front())
            {
                Tpipe.push_back(perTp_refr.front());
                Tannulus.push_back(preTa.front());

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < preRadius[0].front())
                    {
                        Tf_.push_back(preTf[0].front());
                        Pp_.push_back(prePpore[0].front());
                    }
                    else if (curtR > preRadius[0].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < -273)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, preRadius[0], preTf[0]));
                        Pp_.push_back(linerInterpolation4Vector(curtR, preRadius[0], prePpore[0]));
                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
            // 2. case: current well component "AFTER" previous' component
            else if (curtMD > preMD.back())
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }

                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;

                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    Tf_.push_back(tmp);
                    Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                }
                  
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);

            }
            // 3. case: current well component "BELONG TO" previous' component
            else
            {
                Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
                Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));

                // 3.a. set "preIndx" and suitale radius/ Tf profile
                // note: first, need set prevoius formation temperature profile to current compoent
                // then, special for curtR

                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                   // std::cout << i << ", " << j << std::endl;

                    double curtR = Radius[i][j];
                    if (curtR < preRadius[i].front())
                    {
                        Tf_.push_back(preTf[i].front());
                        Pp_.push_back(prePpore[i].front());
                    }
                    else if (curtR > preRadius[i].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp <-273.00)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);

                    }
                    else
                    {
                        Tf_.push_back(interp2DTf(curtMD, curtR));
                        Pp_.push_back(interp2DPp(curtMD, curtR));

                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
        }
       // std::cout << "tmp end: " << tmp << std::endl;
    }
    catch (const std::exception& e)
    {
        std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
        throw std::runtime_error(error);
    }
}
```







这段代码定义了 `HeatTransfer` 类的一个成员函数 `TemperatureResultsRemapping`，其功能是根据输入的多组数据（如测深、温度、孔隙压力等）对温度计算结果进行重新映射或处理。接下来对该函数的语法结构和内容进行详细解析：

### 函数签名

```cpp
void HeatTransfer::TemperatureResultsRemapping(
    const VarList& h, 
    const std::vector<double>& preMD,
    const std::vector<double>& preTp, 
    const std::vector<double>& preTa, 
    const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, 
    const std::vector<std::vector<double>>& prePpore)
```

1. **返回类型 (`void`)**: 
   - 该函数没有返回值，表示函数执行时只做一些操作，不需要返回数据给调用者。

2. **`HeatTransfer::TemperatureResultsRemapping`**:
   - **类名`HeatTransfer`**: 表示这是 `HeatTransfer` 类中的一个成员函数。
   - **`TemperatureResultsRemapping`**: 函数名，说明这个函数负责“重新映射”温度结果（即可能是对已有的温度结果进行修正、调整等）。

3. **参数列表**:
   - **`const VarList& h`**: `VarList` 是一种类型（可能是用户自定义的类型），通过引用传递，而且是 `const`，意味着函数不会修改 `h` 的内容。
   - **`const std::vector<double>& preMD`**: 传递的是一维 `double` 类型的 `std::vector`，用于存储“测深”数据（或其他相关数据）。`const` 表明 `preMD` 不会在函数内被修改，且通过引用传递提高效率。
   - **`const std::vector<double>& preTp`**: 传递的是一维 `std::vector`，可能用于存储管道的温度数据（Tp 可以解释为 Pipe Temperature）。
   - **`const std::vector<double>& preTa`**: 传递的是一维 `std::vector`，可能用于存储环空的温度数据（Ta 可以解释为 Annulus Temperature）。
   - **`const std::vector<std::vector<double>>& preRadius`**: 传递的是二维 `std::vector`，可能用于存储不同层级的半径数据。二维向量常用于存储不同深度或位置的多组值。
   - **`const std::vector<std::vector<double>>& preTf`**: 传递的是二维 `std::vector`，可能用于存储形成温度数据（Tf 可以解释为 Formation Temperature）。
   - **`const std::vector<std::vector<double>>& prePpore`**: 传递的是二维 `std::vector`，可能用于存储不同深度的孔隙压力数据（Ppore 可以解释为 Pore Pressure）。

### 函数体解析

```cpp
{
    Radius.clear();
    Ppore.clear();
    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
}
```

1. **`Radius.clear();`**:
   - `Radius` 是类中的成员变量，用于存储半径数据。这里调用 `clear()` 函数清除之前的数据，确保接下来重新赋值时数据是干净的。
   
2. **`Ppore.clear();`**:
   - 同样，清除类中用于存储孔隙压力数据的成员变量 `Ppore`。

3. **`Tpipe.clear(); Tannulus.clear(); Tformation.clear();`**:
   - 分别清空存储管道温度（`Tpipe`）、环空温度（`Tannulus`）和形成温度（`Tformation`）的类成员变量。这样可以保证在函数内进行数据重新映射时，原有数据不会影响新的计算。

### 拷贝数据

```cpp
size_t nz = preTf.size();
Radius = preRadius;
```

1. **`size_t nz = preTf.size();`**:
   - `nz` 是用来存储 `preTf` 的大小（即第一维的长度），`preTf` 是一个二维数组，这里通过 `.size()` 获取数组的大小。
   - `size_t` 是无符号整型，通常用于表示容器的大小，因为它可以确保不会出现负值。

2. **`Radius = preRadius;`**:
   - 这行代码将输入的 `preRadius` 赋值给类成员变量 `Radius`。注意，这里是直接赋值，而不是通过循环逐一赋值。`std::vector` 支持直接赋值操作，`Radius` 和 `preRadius` 都是 `std::vector<std::vector<double>>` 类型，因此这种赋值操作有效。

### 可能的函数扩展
虽然现在只进行了数据清空和简单的赋值，后续代码很可能包括更多复杂的计算或数据处理操作，比如对温度和压力的重映射。通过 `nz`（前面定义的 `preTf` 的大小），可以推测后续可能会根据数据的深度维度来处理不同层级的温度和压力数据。

### 小结

- 该函数的主要功能是接收若干预先计算好的温度、半径和压力数据，首先清空现有的数据成员变量，然后对数据进行赋值和可能的后续处理。
- 语法上使用了 `std::vector` 进行动态数组操作，并通过 `clear()` 清空数据，确保在处理新数据时不会受到旧数据的干扰。



**void HeatTransfer::TemperatureResultsRemapping**

```

void HeatTransfer::TemperatureResultsRemapping(const VarList& h, const std::vector<double>& preMD,
    const std::vector<double>& preTp, const std::vector<double>& preTa, const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, const std::vector<std::vector<double>>& prePpore)
{
    Radius.clear();
    Ppore.clear();
    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
    size_t nz = preTf.size();
    Radius = preRadius;

     try
     {
        // STEP2: pore pressure profile.
       // Ppore = prePpore;
        // STEP3:
        // if previous heat profile "NOT" valid.
        if (preTp.size() < 1 || preTa.size() != preTf.size())
        {
            for (int i = 0; i < nz; ++i)
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        +std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }
                Tpipe.push_back(tmp);//钻杆温度
                Tannulus.push_back(tmp);//环空温度

                std::vector<double> Tf_;//
                for (size_t j = 0; j < Radius[i].size(); j++)
                    Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
                // std::cout << "check line 104, indx i: " << i << "\t currMD: " << XYZ_Series[i].md << " \tTp:" << Tp(i, 0) << "\tsTa: " << Ta(i, 0) << "\tsTf: " << Tf(i, 0) << std::endl;
            }
        }

        // STEP 4:
        // else previous heat profile "IS" valid.
        // if previous Tp profile contian -999.25, means tripping in
        // use annulus's temperature replace of pipe's component.
        std::vector<double> perTp_refr; // refreshed perTp profile
        for (size_t i = 0; i < preTp.size(); i++)
        {
            if (preTp[i] < 0)
                perTp_refr.push_back(preTa[i]);
            else
                perTp_refr.push_back(preTp[i]);
        }
        // STEP 5:
        double curtMD;
        int tmp = 0;

        _2D::BilinearInterpolator<double> interp2DTf;
        _2D::BilinearInterpolator<double> interp2DPp;

        //construct 2D interploation data format
        std::vector<double> preMD2D;
        std::vector<double> preRadius2D;
        std::vector<double> preTf2D;
        std::vector<double> prePore2D;
        for (int i=0;i<preMD.size();i++)
        {
            for (int j=0;j<preRadius[i].size();j++)
            {
                preMD2D.push_back(preMD[i]);
                preRadius2D.push_back(preRadius[i][j]);
                preTf2D.push_back(preTf[i][j]);
                prePore2D.push_back(prePpore[i][j]);
            }
        }
        interp2DTf.setData(preMD2D, preRadius2D, preTf2D);
        interp2DPp.setData(preMD2D, preRadius2D, prePore2D);


        for (size_t i = 0; i < XYZ_Series.size(); i++)
        {
            curtMD = XYZ_Series[i].md;

            // 1. case: current well component "BEFORE" previous' component
            if (curtMD < preMD.front())
            {
                Tpipe.push_back(perTp_refr.front());
                Tannulus.push_back(preTa.front());

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < preRadius[0].front())
                    {
                        Tf_.push_back(preTf[0].front());
                        Pp_.push_back(prePpore[0].front());
                    }
                    else if (curtR > preRadius[0].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < -273)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, preRadius[0], preTf[0]));
                        Pp_.push_back(linerInterpolation4Vector(curtR, preRadius[0], prePpore[0]));
                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
            // 2. case: current well component "AFTER" previous' component
            else if (curtMD > preMD.back())
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }

                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;

                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    Tf_.push_back(tmp);
                    Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                }
                  
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);

            }
            // 3. case: current well component "BELONG TO" previous' component
            else
            {
                Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
                Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));

                // 3.a. set "preIndx" and suitale radius/ Tf profile
                // note: first, need set prevoius formation temperature profile to current compoent
                // then, special for curtR

                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                   // std::cout << i << ", " << j << std::endl;

                    double curtR = Radius[i][j];
                    if (curtR < preRadius[i].front())
                    {
                        Tf_.push_back(preTf[i].front());
                        Pp_.push_back(prePpore[i].front());
                    }
                    else if (curtR > preRadius[i].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp <-273.00)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);

                    }
                    else
                    {
                        Tf_.push_back(interp2DTf(curtMD, curtR));
                        Pp_.push_back(interp2DPp(curtMD, curtR));

                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
        }
       // std::cout << "tmp end: " << tmp << std::endl;
    }
    catch (const std::exception& e)
    {
        std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
        throw std::runtime_error(error);
    }
}
```








结合代码的进一步解析可以帮助深入理解函数各部分的功能和处理流程。该函数核心目的是**重映射钻井过程中的温度和孔隙压力剖面**，并确保即使在先前数据无效或不完整的情况下，也能够计算出准确的温度和压力分布。以下是结合代码的逐步分析：

### 1. **初始化和数据清理**
```cpp
Radius.clear();
Ppore.clear();
Tpipe.clear();
Tannulus.clear();
Tformation.clear();
```
函数开始时，清空了用于存储温度和压力数据的向量，确保在每次调用函数时，这些向量都是空的，避免旧数据的干扰。

```cpp
size_t nz = preTf.size();
Radius = preRadius;
```
这里，`nz` 用来存储先前温度场的数量，而 `Radius` 被初始化为 `preRadius`，为接下来的操作提供半径信息。









### 2. **验证先前的温度剖面有效性**
在这里，代码分成了两条执行路径，取决于先前温度剖面是否有效。

#### a. **先前温度剖面无效**
```cpp
if (preTp.size() < 1 || preTa.size() != preTf.size())
```
如果`preTp` 的大小小于1（即没有有效的管柱温度数据），或者 `preTa` 和 `preTf` 的大小不一致（表示环空温度和地层温度数据不匹配），则视为无效剖面。

在这种情况下，代码进入了一个循环，为每个深度点计算默认的温度。温度的计算基于 `XYZ_Series[i].formInfo.back()->fTemp`，即地层中的温度。如果计算出的温度低于 -273°C，则抛出异常，因为这违反了物理规律。
```cpp
if (tmp < -273)
{
    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
        +std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
    throw(std::runtime_error(err));
}
```
异常处理机制确保了当地层温度异常时，程序能够及时中止并抛出有用的错误信息。

#### b. **先前温度剖面有效**
当剖面有效时，代码检查是否需要更新 `preTp`（钻杆温度）中的数据。若 `preTp` 中包含负值，则意味着发生了“起下钻”，此时使用环空温度 (`preTa`) 替换钻杆温度 (`preTp`)。
```cpp
if (preTp[i] < 0)
    perTp_refr.push_back(preTa[i]);
else
    perTp_refr.push_back(preTp[i]);
```
这个过程确保了即使在不完整或异常的温度数据下，也能得到一个合理的剖面。

### 3. **二维插值**
接下来，代码使用**二维插值计算**钻井过程中不同深度和半径下的温度和孔隙压力分布。
```cpp
_2D::BilinearInterpolator<double> interp2DTf;
_2D::BilinearInterpolator<double> interp2DPp;
```
在这里，定义了两个二**维双线性插值器 `interp2DTf` 和 `interp2DPp`**，分别用于温度和孔隙压力插值。

**构造二维插值数据格式：**

```cpp
std::vector<double> preMD2D;
std::vector<double> preRadius2D;
std::vector<double> preTf2D;
std::vector<double> prePore2D;
for (int i = 0; i < preMD.size(); i++)
{
    for (int j = 0; j < preRadius[i].size(); j++)
    {
        preMD2D.push_back(preMD[i]);
        preRadius2D.push_back(preRadius[i][j]);
        preTf2D.push_back(preTf[i][j]);
        prePore2D.push_back(prePpore[i][j]);
    }
}
interp2DTf.setData(preMD2D, preRadius2D, preTf2D);
interp2DPp.setData(preMD2D, preRadius2D, prePore2D);
```
这里，`preMD2D` 和 `preRadius2D` 保存了先前深度和半径的二维数据，`preTf2D` 和 `prePore2D` 分别存储对应的温度和孔隙压力。通过 **`setData` 方法**将这些数据传入插值器，构造插值器的输入数据。

### 4. **深度点循环计算**
代码遍历 `XYZ_Series`，计算每个深度的当前温度和孔隙压力分布。分为三种情况处理：

#### a. **当前深度点在先前深度之前**
```cpp
if (curtMD < preMD.front())
```
在这种情况下，当前深度小于先前剖面的最小深度，使用先前的 `preTp` 和 `preTa` 中的第一个值作为当前钻杆和环空温度。

对于地层温度和孔隙压力，代码根据当前半径 `curtR` 的大小来判断：
- 如果当前半径小于 `preRadius` 的最小值，则使用 `preTf` 和 `prePpore` 的第一个值；
- 如果当前半径大于 `preRadius` 的最大值，则使用地层温度和孔隙压力数据（`XYZ_Series[i].formInfo.back()`）作为默认值。

#### b. **当前深度点在先前深度之后**
```cpp
else if (curtMD > preMD.back())
```
此时，当前深度点大于先前的深度点，直接使用地层温度和孔隙压力数据进行填充。这里同样进行物理约束检查，防止温度低于 -273°C。

#### c. **当前深度点在先前深度范围内**
```cpp
else
{
    Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
    Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));
```
当当前深度在先前深度范围内时，代码使用 `linerInterpolation4Vector` 函数进行线性插值，计算出当前深度下的钻杆温度和环空温度。同样地，对于每个半径点，使用二维插值器 `interp2DTf` 和 `interp2DPp` 计算当前半径和深度下的地层温度和孔隙压力分布：
```cpp
Tf_.push_back(interp2DTf(curtMD, curtR));
Pp_.push_back(interp2DPp(curtMD, curtR));
```

### 5. **异常处理**
在**整个函数中，关键的计算部分都包含在 `try-catch`** 块中，以**捕获并抛出异常**。在捕获到异常时，函数会抛出详细的错误信息，指出具体错误发生的位置：
```cpp
catch (const std::exception& e)
{
    std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
    throw std::runtime_error(error);
}
```

### 总结
- **核心功能**：该函数通过线性插值和双线性插值，结合当前深度和半径，计算钻井过程中不同区域的温度和孔隙压力。
- **逻辑结构**：根据深度点的位置，函数灵活选择先前剖面的数据或默认的地层数据，并确保在无效或缺失数据时，程序能够继续计算出合理的温度和压力剖面。
- **插值策略**：利用二维插值器，使得温度和压力的计算不仅仅依赖于深度，还考虑了不同半径的影响。

这种设计确保了在处理复杂的钻井温度和压力剖面时，能够准确反映真实物理过程，同时能够处理数据异常和不完整情况。













在这一部分代码中，我们看到循环遍历了从 `0` 到 `nz-1` 的索引，其中 `nz` 表示深度点的数量。这个循环的目的是为每个深度点获取远场（地层）的温度属性。让我们进一步解析其中的细节：

### 1. **变量 `tmp` 的作用**
```cpp
double tmp = XYZ_Series[i].formInfo.back()->fTemp;
```
这里 `tmp` 被定义为当前深度点的地层温度，它是从 `XYZ_Series[i].formInfo.back()` 中提取的。`XYZ_Series` 是一个**保存了各个深度点信息的结构体数组**，而 `formInfo.back()` **返回的是每个深度点的地层信息对象，**其中包含属性 `fTemp`，即地层温度。

原始代码中还有被注释掉的一行：
```cpp
// double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
```
这行代码表示了另一种可能的温度计算方式。在这种情况下，`tmp` 的值不仅取决于地层温度 `fTemp`，还会考虑地表温度 `h.surfTemp` 和深度 `z`。这种计算方式可以反映温度随着深度的线性变化趋势。

具体含义如下：
- **`h.surfTemp`**：地表温度，可以理解为某种初始温度条件。
- **`XYZ_Series[i].z`**：当前深度点的深度，表示从地表到当前深度点的距离。
- **`XYZ_Series[i].formInfo.back()->fTemp`**：地层温度梯度，用于描述随着深度变化的温度变化率。

注释掉的这行代码试图计算温度的线性变化，即地表温度加上深度与温度梯度的乘积，通常用于估算深度较小区域的温度变化。如果假设温度随着深度线性上升，那么这个公式可以较为准确地估算地层中的温度。

### 2. **当前实现的逻辑**
由于注释掉了地表温度的影响，当前代码直接使用 `formInfo.back()->fTemp` 获取每个深度点的地层温度。这种实现更加简单，假设在每个深度点 `i` 处，地层温度已经被直接给出，不需要计算深度和地表温度的影响。

### 3. **对实际应用的影响**
- **如果使用当前的实现方式**，地层温度的计算仅依赖于 `fTemp`，这意味着数据源提供的每个深度点的温度已经是经过计算或测量的温度值，程序只需要提取这些数据即可。
- **如果使用注释掉的方式**，则程序会根据深度和温度梯度计算温度，这适用于一些场景下温度没有直接给出，而需要通过地层温度梯度进行估算的情形。

### 4. **如何选择实现方式**
具体选择哪种实现方式取决于你所处理的温度数据的特点：
- 如果地层温度数据已经通过某种方式（如地质模型或测量数据）提供给程序，当前实现方式更为直接。
- 如果温度需要根据地表温度和深度进行估算，则可以使用注释掉的公式来计算温度的变化。

### 建议
- 如果在实际场景中，地层温度梯度和深度对于计算至关重要，建议恢复注释掉的代码，以确保能够计算出随深度变化的温度分布。
- 如果数据已经很完善，直接提取温度值则足够，当前代码可以继续保持简单的实现。

你可以根据你正在处理的钻井数据源和模型需求来决定是直接提取 `fTemp` 还是使用更复杂的温度计算公式。





```cpp
double tmp = XYZ_Series[i].formInfo.back()->fTemp;
```

这行代码用于从 `XYZ_Series` 数据结构中提取当前深度点的地层温度 `fTemp`，并将其存储在 `tmp` 变量中。接下来我将详细解析这行代码涉及的各个部分以及它的具体功能和含义。

### 1. **`XYZ_Series[i]`**
- `XYZ_Series` 是一个数组或向量，存储了与不同深度点相关的地质和温度信息。
- `i` 是当前深度点的索引。代码通过 `for` 循环遍历 `XYZ_Series`，`i` 从 `0` 到 `nz-1`，代表不同深度的点（`nz` 是深度点的总数）。
- 换句话说，`XYZ_Series[i]` 表示与深度点 `i` 相关的所有信息。

### 2. **`formInfo.back()`**
- `formInfo` 是 `XYZ_Series[i]` 的一个成员变量，通常为一个包含不同深度地层信息的容器（比如向量、列表等）。它可能包含当前深度点的多个地层信息，从浅到深。
- `.back()` 方法用于返回 `formInfo` 容器中的最后一个元素。通常这种用法意味着该元素代表了地层的“最远场”或“最深层”信息，因为它是地质构造的末端数据。
  - **地层信息解释**：`formInfo` 可能存储的是从浅层到深层的不同地层温度信息，`.back()` 提取最后一个数据，表示该深度点对应的地层最底部或远场温度。

### 3. **`fTemp`**
- `fTemp` 是 `formInfo.back()` 返回的地层信息结构体或对象中的一个成员变量，它代表了当前深度点的**地层温度**（formation temperature）。
- `fTemp` 具体指的是这个深度点处，地层的温度值。这个温度通常是通过地质测量、模型计算或者某些实验方法获得的。

### 4. **`double tmp = ...`**
- `tmp` 是一个临时变量，用于存储从 `XYZ_Series[i].formInfo.back()->fTemp` 中获取的地层温度。这里，`tmp` 将保存当前深度点 `i` 的地层温度值，供后续操作或判断使用。
- `tmp` 这个变量在后面的代码中会被用于设置钻杆温度（`Tpipe`）、环空温度（`Tannulus`）和地层温度（`Tformation`）等多个方面，确保在计算钻井过程中考虑地层的实际温度分布。

### 5. **实际场景解释**
这行代码的核心功能是在处理与钻井或地层相关的热传导或温度分布模型时，提取地层的温度数据。程序将地层温度作为输入，用于后续的热力学分析，确保模型可以在不同深度点上准确地计算钻井管、环空以及周围地层的温度变化。

- **地层温度的重要性**：在钻井工程中，地层温度是一个关键因素。它影响钻井液的温度、泥浆的热传递、钻具和环空的温度，以及井壁的稳定性。因此，在不同深度准确获取地层温度对整个模型的热力学计算是非常重要的。

### 6. **数据结构假设**
基于这段代码，可以推测 `XYZ_Series[i].formInfo.back()` 是一个存储了地质层信息的复杂数据结构，其 `fTemp` 属性表示当前深度点的地层温度。通常这种数据结构用于模拟钻井过程中不同深度的热力学状态，包括地层温度、孔隙压力等物理特性。

### 总结
- `XYZ_Series[i].formInfo.back()->fTemp` 表示的是当前深度点的地层的温度信息。

- 这行代码从 `XYZ_Series` 中提取最后一个地层的温度，并存储在 `tmp` 变量中，以便在后续的钻井热力模型中使用。

  

  

  [C++面向对象整理（10）之异常与捕获（try、catch、throw、noexcept）_c++ try catch捕获异常-CSDN博客](https://blog.csdn.net/ULTRAmanTAROACE/article/details/137072356?ops_request_misc=%7B%22request%5Fid%22%3A%22ADDC9D78-BA5E-4546-9D6E-CC32DD1EFB0A%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=ADDC9D78-BA5E-4546-9D6E-CC32DD1EFB0A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-137072356-null-null.142^v100^pc_search_result_base4&utm_term=try catch捕获多个异常&spm=1018.2226.3001.4187)

  

  ##  **二维双线性插值（`BilinearInterpolator`）**

   MD（测量深度）和半径的组合双线性插值是一种用于二维数据的插值方法，

  它的原理是：

  先在一个方向上（比如 X 轴或 MD）进行线性插值。**深度上**

  再在另一个方向上（比如 Y 轴或 Radius）进行线性插值。**半径**

  通过这两次线性插值来估算任意中间点的值。

  

  `#include "libInterpolate/Interpolate.hpp"` 这一行代码的作用是引入一个名为 `Interpolate` 的自定义插值库，通常用于执行数据插值操作。具体来说，这个库可能包含以下内容：

  1. **插值算法**：实现不同的插值方法，如线性插值、拉格朗日插值、样条插值等，用于在已知数据点之间估算未知值。

  2. **数据结构**：定义用于存储数据点的结构，例如数组或向量，方便插值操作。
  
  3. **函数接口**：提供调用插值算法的函数，例如根据输入的已知数据点和目标位置返回插值结果。
  
  4. **异常处理**：可能包括处理边界情况和异常的代码，以确保插值过程的稳定性。
  
  库在热传递模拟等应用中可能非常重要，因为它可以帮助在离散的数据点之间生成连续的结果，从而提供更精确的计算。
  
  
  
  `HeatTransfer` 类中的 `TemperatureResultsRemapping` 方法，主要用于重新映射温度结果。
  
  1. **变量初始化**：首先清空类成员 `Radius`、`Ppore`、`Tpipe`、`Tannulus` 和 `Tformation`，并初始化 `nz` 为 `preTf` 的大小。
  
  2. **半径赋值**：将 `preRadius` 的值赋给 `Radius`。
  
  3. **异常处理**：使用 `try` 块来捕获可能的异常。
  
  4. **条件检查**：检查 `preTp` 的大小和 `preTa` 的大小是否与 `preTf` 一致。如果 `preTp` 的大小小于1或 `preTa` 的大小不匹配，执行以下逻辑：
  
  5. **温度赋值**：遍历 `nz`，获取每个位置的**远场温度属性 `fTemp`**，并进行有效性检查（如温度不能低于绝对零度）。若温度无效，抛出异常。
  
  6. **温度存储**：将**有效的温度值**分别推入 `Tpipe` 和 `Tannulus`，并为每个半径生成一个温度向量 `Tf_`，存储在 `Tformation` 中。
  
  此函数的最终目的是确保在无效的温度数据时为管道和环形空间提供合理的温度估算，并记录相应的形成温度。
  
  远场温度属性 `fTemp
  
  
  
  这段代码继续 `TemperatureResultsRemapping` 方法的逻辑，主要功能是构建和准备数据用于后续的插值计算。以下是详细的逻辑分析：
  
  1. **创建刷新后的温度配置**：
     - `std::vector<double> perTp_refr;` 声明了一个用于存储刷新后的温度配置的向量。
     - 遍历 `preTp`，如果 `preTp[i]` 小于 0，表示无效或缺失数据，则将 `preTa[i]`（环空温度）添加到 `perTp_refr`；否则，将 `preTp[i]`（管道温度）添加进去。
  
  2. **准备插值数据**：
     - 声明 `curtMD` 和 `tmp`，这两个变量将在后续处理中使用。
     - 声明两个 `BilinearInterpolator` 对象：`interp2DTf` 和 `interp2DPp`，用于二维插值，分别用于温度和**孔隙压力**的插值。
  
  3. **构建二维插值数据格式**：
     - 声明四个用于存储插值所需数据的向量：`preMD2D`、`preRadius2D`、`preTf2D` 和 `prePore2D`。
     - 双重循环遍历 `preMD` 和 `preRadius`，将每个深度和对应半径的数据展开到一维向量中。
       - `preMD2D` 存储深度数据。
       - `preRadius2D` 存储半径数据。
       - `preTf2D` 存储温度数据。
       - `prePore2D` 存储孔隙压力数据。
  
  4. **设置插值数据**：
     - 使用 `setData` 方法为两个插值对象提供数据。这将使得后续可以根据需要进行插值计算。
  
  ### 总结
  该段代码的主要功能是准备插值所需的数据，并确保能有效地处理无效温度数据。通过构建一维数据格式，它为后续的插值过程奠定了基础。
  
  
  
  这段代码继续 `TemperatureResultsRemapping` 方法，主要功能是根据当前井筒的位置相对于之前的温度和压力数据，决定如何设置管道温度、环空温度及形成温度。以下是详细分析：
  
  1. **循环遍历 `XYZ_Series`**：
     - 通过 `for` 循环遍历 **`XYZ_Series`** 的每个元素，获取当前深度 `curtMD`。
  
  2. **处理当前井筒位于之前组件之前的情况**：
     - 如果 `curtMD` 小于 `preMD.front()`：
       - 将 `perTp_refr.front()` 和 `preTa.front()` 添加到 `Tpipe` 和 `Tannulus` 中，分别表示管道和环空的温度。
       - 创建两个空向量 `Tf_` 和 `Pp_` 用于存储当前形成温度和孔隙压力。
  
  3. **生成当前形成温度和压力配置**：
     - 内部循环遍历当前半径 `Radius[i]`：
       - 如果当前半径 `curtR` 小于 `preRadius[0].front()`，使用初始状态的温度和孔隙压力。
       - 如果 `curtR` 大于 `preRadius[0].back()`，使用远场属性，获取当前形成温度和孔隙压力，并进行有效性检查。
       - 如果 `curtR` 在范围内，则使用线性插值函数 `linerInterpolation4Vector` 获取对应的温度和孔隙压力。
  
  4. **处理当前井筒位于之前组件之后的情况**：
     - 如果 `curtMD` 大于 `preMD.back()`：
       - 同样获取远场属性并进行有效性检查。
       - 将温度值添加到 `Tpipe` 和 `Tannulus` 中。
       - 将温度和孔隙压力值填充到 `Tf_` 和 `Pp_` 向量中。
  
  5. **将温度和压力数据添加到成员变量**：
     - 将 `Tf_` 和 `Pp_` 向量分别添加到 `Tformation` 和 `Ppore` 中。
  
  ### 总结
  此段代码的主要功能是根据当前井筒深度与之前组件的关系，决定温度和孔隙压力的设置方法，确保在不同深度下温度和压力的合理性。它实现了对井筒不同位置的温度和压力的有效映射。
  
  
  
  
  
  这段代码是 `TemperatureResultsRemapping` 方法的最后部分，主要用于处理当前井筒深度位于之前组件深度范围内的情况。以下是详细的逻辑分析：
  
  1. **温度和压力计算**：
     - 使用 `linerInterpolation4Vector` 函数根据当前深度 `curtMD` 从 `preMD` 和对应的温度 `perTp_refr`、环空温度 `preTa` 中计算并推入 `Tpipe` 和 `Tannulus` 中。
  
  2. **设置形成温度和孔隙压力配置**：
     - 创建两个空向量 `Tf_` 和 `Pp_`，用于存储形成温度和孔隙压力数据。
     - 遍历当前半径 `Radius[i]`：
  
  3. **根据当前半径设置温度和压力**：
     - 如果当前半径 `curtR` 小于 `preRadius[i].front()`，则使用前一个温度和压力值（即 `preTf[i].front()` 和 `prePpore[i].front()`）。
     - 如果 `curtR` 大于 `preRadius[i].back()`，则使用远场属性。首先获取形成温度 `tmp`，并进行有效性检查（不得低于绝对零度）。然后将温度和孔隙压力推入向量。
     - 如果 `curtR` 在范围内，使用之前创建的插值对象 `interp2DTf` 和 `interp2DPp` 进行二维插值，获取当前深度和半径下的温度和孔隙压力。
  
  4. **保存当前组件的温度和压力**：
     - 将构造好的 `Tf_` 和 `Pp_` 向量添加到成员变量 `Tformation` 和 `Ppore` 中。
  
  5. **异常处理**：
     - 使用 `try-catch` 块捕获可能发生的异常。如果发生异常，将错误信息附加上下文信息并重新抛出。
  
  ### 总结
  这段代码实现了在当前井筒深度处于之前组件的范围内时，温度和孔隙压力的合理设置。通过插值和条件判断，确保了数据的准确性和合理性。同时，异常处理机制增强了代码的健壮性，能更好地应对潜在的错误。
  **304——513**
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
