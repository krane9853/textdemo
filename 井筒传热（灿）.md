# 热码（灿）**

D:\传热资料\theraml_data\thermalModel\cpp\Temperature
// WellboreHeatTransfer.cpp
//井筒传热部分

```c++
// WellboreHeatTransfer.cpp

#include "Temperature/WellboreHeatTransfer.h"
#include <cmath>
#include <algorithm> // for swap() function
#include <functional>
#include"libInterpolate/Interpolate.hpp"
/*
void HeatTransfer::TemperatureResultsRemapping(const VarList& h, const std::vector<double>& preMD,
    const std::vector<double>& preTp, const std::vector<double>& preTa, const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, const std::vector<std::vector<double>>& prePpore)
{
    Radius.clear();

    Ppore.clear();
    MD.clear();

    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
    size_t nz = preTf.size();
    //int nz = (int)XYZ_Series.size();
    try
    {

        
        /*
        const double TOL = 1.0e-8;
        double rw = XYZ_Series.front().d / 2.0;
        if (fabs(h.eps - 1.0) > TOL)
        {
            nr = (int)ceil(log(1.0 - (1.0 - h.eps) * (h.re - rw) / h.dr) / log(h.eps)) + 1;
        }
        else
        {
            nr = (int)ceil((h.re - rw) / h.dr) + 1;
        }
        

        // STEP1:
        // initial raduis profile.
        //int pz = int(h.dzOut / h.dz); // get integer part
        //int pr = int(h.drOut / h.dr); // get integer part
        int pz = int(30 / 30); // get integer part
        int pr = int(0.06 / 0.06); // get integer part

        //int mr = (int)ceil(double(nr - 1) / double(pr)) + 1; // equal to "nr" ,if pr=1.

        size_t i = 0, i0 = 0;
        Radius = preRadius;
        //while (i < nz)
        //{
            //preTf[i]
            //int j1 = 0, j0 = 0;
            // dimensionless radius
            //std::vector<double> rad_dims;
            //rad_dims.resize(mr);
            /*
            // tural radius of curt component
            std::vector<double> rad_;
            while (j0 < nr - 1)
            {
                double eps1;
                if (fabs(h.eps - 1.0) <= TOL)
                    eps1 = j0;
                else
                    eps1 = (1.0 - pow(h.eps, j0)) / (1.0 - h.eps);
                rad_dims[j1] = (XYZ_Series[i0].d / 2.0 + eps1 * h.dr) / (XYZ_Series[i0].d / 2.0);

                j0 += pr;
                ++j1;
            }
            // add last data point in radius dimension
            rad_dims[mr - 1] = h.re / (XYZ_Series[i0].d / 2.0);

            // set radius value with dimension value
            for (size_t i = 0; i < rad_dims.size(); i++)
                rad_.push_back(rad_dims[i] * (XYZ_Series[i0].d / 2.0));
            Radius.push_back(rad_);
            i0 += pz;
            ++i1;
            
       // }

        // STEP2:
        // initial pore pressure profile.
        Ppore = prePpore;
        
        for (int i = 0; i < nz; ++i)
        {
            std::vector<double> Pp_;

            //Pp(i, 0, 0) = Pa_Series[i];
            Pp_.push_back(Pa_Series[i]);// set pore pressure value along wellbore/annulus

            // get far field property.
            double tmp = XYZ_Series[i].formInfo.back()->Ppore * XYZ_Series[i].z;

            for (size_t j = 1; j < Radius[i].size(); j++)
                Pp_.push_back(tmp);
            Ppore.push_back(Pp_);

            MD.push_back(XYZ_Series[i].md);
        }
        

        // STEP3:
        // if previous heat profile "NOT" valid.
        if (preTp.size() < 1 || preTa.size() != preTf.size())
        {
            for (int i = 0; i < nz; ++i)
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < 273.15 + 4)
                {
                    tmp = 273.15 + 4.0;
                }
                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                std::vector<double> Tf_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                    Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
                // std::cout << "check line 104, indx i: " << i << "\t currMD: " << XYZ_Series[i].md << " \tTp:" << Tp(i, 0) << "\tsTa: " << Ta(i, 0) << "\tsTf: " << Tf(i, 0) << std::endl;
            }            
            // MUST!
            return;
        }

        // STEP4:
        // else previous heat profile "IS" valid.
        // if previous Tp profile contian -999.25, means tripping in
        // use annulus's temperature replace of pipe's component.
        std::vector<double> perTp_refr; // refreshed perTp profile
        for (size_t i = 0; i < preTp.size(); i++)
        {
            if (preTp[i] < 0)
                perTp_refr.push_back(preTa[i]);
            else
                perTp_refr.push_back(preTp[i]);
        }

        // STEP5:
        double curtMD;
        int tmp = 0;

        for (size_t i = 0; i < XYZ_Series.size(); i++)
        {
            curtMD = XYZ_Series[i].md;

            // 1. case: current well component "BEFORE" previous' component
            if (curtMD < preMD.front())
            {
                Tpipe.push_back(perTp_refr.front());
                Tannulus.push_back(preTa.front());

                // set current formation's temperature profile
                std::vector<double> Tf_;
                //for (size_t j = 1; j < Radius[i].size(); j++)
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < preRadius[0].front())
                    {
                        Tf_ .push_back(preTf[0].front());
                    }
                    else if (curtR > preRadius[0].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < 273.15 + 4)
                        {
                            tmp = 273.15 + 4.0;
                        }
                        Tf_.push_back(tmp);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, preRadius[0], preTf[0]));
                    }
                }
                Tformation.push_back(Tf_);
            }
            // 2. case: current well component "AFTER" previous' component
            else if (curtMD > preMD.back())
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < 273.15 + 4)
                    tmp = 273.15 + 4.0;

                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                // set current formation's temperature profile
                std::vector<double> Tf_;

                for (size_t j = 0; j < Radius[i].size(); j++)
                   Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
            }
            // 3. case: current well component "BELONG TO" previous' component
            else
            {
                Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
                Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));

                // 3.a. set "preIndx" and suitale radius/ Tf profile
                // note: first, need set prevoius formation temperature profile to current compoent
                // then, special for curtR 
                int preIndx = -99;

                std::vector<double> raduis_suit4CurtMDComp;
                std::vector<double> Tf_suit4CurtMDComp;
                for (size_t m = 1; m < preMD.size(); m++)
                {
                    if (curtMD < preMD[m])
                    {
                        preIndx = m;
                        break;
                    }
                }

                // 3.b. if "NO" get indx, mean: curt md is buttom.
                if (preIndx < 0)
                {
                    raduis_suit4CurtMDComp = preRadius.back();
                    Tf_suit4CurtMDComp = preTf.back();
                }
                else
                {
                    for (size_t j = 0; j < preRadius[preIndx].size(); j++)
                    {
                        std::vector<double> md_suit4CurtComp_2Doit;
                        std::vector<double> raduis_suit4CurtComp_2Doit;
                        std::vector<double> Tf_suit4CurtComp_2Doit;

                        md_suit4CurtComp_2Doit.push_back(preMD[preIndx-1]);
                        md_suit4CurtComp_2Doit.push_back(preMD[preIndx]);

                        raduis_suit4CurtComp_2Doit.push_back(preRadius[preIndx - 1][j]);
                        raduis_suit4CurtComp_2Doit.push_back(preRadius[preIndx][j]);
                        raduis_suit4CurtMDComp.push_back(linerInterpolation4Vector(curtMD, md_suit4CurtComp_2Doit, raduis_suit4CurtComp_2Doit));

                        Tf_suit4CurtComp_2Doit.push_back(preTf[preIndx - 1][j]);
                        Tf_suit4CurtComp_2Doit.push_back(preTf[preIndx][j]);
                        Tf_suit4CurtMDComp.push_back(linerInterpolation4Vector(curtMD, md_suit4CurtComp_2Doit, Tf_suit4CurtComp_2Doit));
                    }
                }

                // 3.c. set current formation's temperature profile
                std::vector<double> Tf_;

                //std::cout << "tmp+1: " << tmp << std::endl;
                //tmp++;
                //if(tmp==335)
                //    std::cout << "tmp+0: " << tmp << std::endl;

                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < raduis_suit4CurtMDComp.front())
                    {
                        Tf_.push_back(Tf_suit4CurtMDComp.front());
                    }
                    else if (curtR > raduis_suit4CurtMDComp.back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < 273.15 + 4)
                        {
                            tmp = 273.15 + 4.0;
                        }
                        Tf_.push_back(tmp);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, raduis_suit4CurtMDComp, Tf_suit4CurtMDComp));
                    }
                }
                Tformation.push_back(Tf_);

                //std::cout << "tmp+2: " << tmp << std::endl;
            }
        }
        std::cout << "tmp end: " << tmp << std::endl;
    }
    catch (const std::exception& e)
    {
        std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
        throw std::runtime_error(error);
    }
}
*/


void HeatTransfer::TemperatureResultsRemapping(const VarList& h, const std::vector<double>& preMD,
    const std::vector<double>& preTp, const std::vector<double>& preTa, const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, const std::vector<std::vector<double>>& prePpore)
{
    Radius.clear();
    Ppore.clear();
    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
    size_t nz = preTf.size();
    Radius = preRadius;

     try
     {
        // STEP2: pore pressure profile.
       // Ppore = prePpore;
        // STEP3:
        // if previous heat profile "NOT" valid.
        if (preTp.size() < 1 || preTa.size() != preTf.size())
        {
            for (int i = 0; i < nz; ++i)
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        +std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }
                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                std::vector<double> Tf_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                    Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
                // std::cout << "check line 104, indx i: " << i << "\t currMD: " << XYZ_Series[i].md << " \tTp:" << Tp(i, 0) << "\tsTa: " << Ta(i, 0) << "\tsTf: " << Tf(i, 0) << std::endl;
            }
        }

        // STEP 4:
        // else previous heat profile "IS" valid.
        // if previous Tp profile contian -999.25, means tripping in
        // use annulus's temperature replace of pipe's component.
        std::vector<double> perTp_refr; // refreshed perTp profile
        for (size_t i = 0; i < preTp.size(); i++)
        {
            if (preTp[i] < 0)
                perTp_refr.push_back(preTa[i]);
            else
                perTp_refr.push_back(preTp[i]);
        }
        // STEP 5:
        double curtMD;
        int tmp = 0;

        _2D::BilinearInterpolator<double> interp2DTf;
        _2D::BilinearInterpolator<double> interp2DPp;

        //construct 2D interploation data format
        std::vector<double> preMD2D;
        std::vector<double> preRadius2D;
        std::vector<double> preTf2D;
        std::vector<double> prePore2D;
        for (int i=0;i<preMD.size();i++)
        {
            for (int j=0;j<preRadius[i].size();j++)
            {
                preMD2D.push_back(preMD[i]);
                preRadius2D.push_back(preRadius[i][j]);
                preTf2D.push_back(preTf[i][j]);
                prePore2D.push_back(prePpore[i][j]);
            }
        }
        interp2DTf.setData(preMD2D, preRadius2D, preTf2D);
        interp2DPp.setData(preMD2D, preRadius2D, prePore2D);


        for (size_t i = 0; i < XYZ_Series.size(); i++)
        {
            curtMD = XYZ_Series[i].md;

            // 1. case: current well component "BEFORE" previous' component
            if (curtMD < preMD.front())
            {
                Tpipe.push_back(perTp_refr.front());
                Tannulus.push_back(preTa.front());

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < preRadius[0].front())
                    {
                        Tf_.push_back(preTf[0].front());
                        Pp_.push_back(prePpore[0].front());
                    }
                    else if (curtR > preRadius[0].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < -273)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, preRadius[0], preTf[0]));
                        Pp_.push_back(linerInterpolation4Vector(curtR, preRadius[0], prePpore[0]));
                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
            // 2. case: current well component "AFTER" previous' component
            else if (curtMD > preMD.back())
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }

                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;

                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    Tf_.push_back(tmp);
                    Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                }
                  
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);

            }
            // 3. case: current well component "BELONG TO" previous' component
            else
            {
                Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
                Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));

                // 3.a. set "preIndx" and suitale radius/ Tf profile
                // note: first, need set prevoius formation temperature profile to current compoent
                // then, special for curtR

                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                   // std::cout << i << ", " << j << std::endl;

                    double curtR = Radius[i][j];
                    if (curtR < preRadius[i].front())
                    {
                        Tf_.push_back(preTf[i].front());
                        Pp_.push_back(prePpore[i].front());
                    }
                    else if (curtR > preRadius[i].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp <-273.00)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);

                    }
                    else
                    {
                        Tf_.push_back(interp2DTf(curtMD, curtR));
                        Pp_.push_back(interp2DPp(curtMD, curtR));

                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
        }
       // std::cout << "tmp end: " << tmp << std::endl;
    }
    catch (const std::exception& e)
    {
        std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
        throw std::runtime_error(error);
    }
}


void HeatTransfer::HeatTransferCal2D(const VarList& h, const std::vector<double> & preMD, 
    const std::vector<double> & preTp, const std::vector<double> & preTa, const std::vector<std::vector<double>> & preRadius,
    const std::vector<std::vector<double>> &preTf, const std::vector<std::vector<double>>& prePpore)
{
    const double PI = 3.14159265358979;
    const double TOL = 1.0e-8;

    // mechanical heat rate generated
    std::vector<double> qs = HeatByDragForce(h);
    double qb = HeatByDrillbit(h);

    //这又没有考虑钻头摩擦生热，2023-07-23
    qb = 0; //temp ignore bit
    qs.back() += qb; // add heat at drillbit
    //qs.clear();
    //----------------------------------------------------------------------------------------------------------------//
  
    // calculate the number of nodes in each dimension for calculation
    int nz, nt;//nodes of z axial ,time
    nz = (int)XYZ_Series.size();
    // assuming that (re - rw) is constant
    double rw = XYZ_Series.front().d / 2.0;
 
    //------------- remapping previous results to current mesh --------------
    //     Ppore, Radius, Tpipe, Tannulus, Tformation
    TemperatureResultsRemapping(h, preMD, preTp, preTa, preRadius, preTf,prePpore);

    /**************************************************************************
    * Main Computation Zone.
    * Description: Explicit method, with upwind scheme.
    * Ref: Master's thesis of Duc A. Nguyen.
    * Equ: 4.1.
    **************************************************************************/
    //int n2 = pt, n3 = 1; // for main data matrices
    double ds;
    int nr;
        /**************************************************************************
        * Description: Formula of calculating pore pressure profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/
    int fmaIndex; 

        //----------------------------------------------------------------------------------------//
        /**************************************************************************
        * Description: Formula of calculating drillpipe fluid temperature profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/
      
        Tpipe[0] = h.Tin;

        // main profile
        for (int i = 1; i < nz; ++i)
        {
            ds = XYZ_Series[i].md - XYZ_Series[i - 1].md;
            double B1, B2;
            //20201011DEBUG via kxpt@me.com
            // overall heat transfer coefficient between drillpipe and annulus fluid
            double Uap = XYZ_Series[i].fluidAnn.hc;
            if (XYZ_Series[i].pOR > 0.0)
            {
                Uap = 1.0 / (XYZ_Series[i].pOR / (XYZ_Series[i].pIR * XYZ_Series[i].fluidPipe.hc) + 
                    XYZ_Series[i].pOR * log(XYZ_Series[i].pOR / XYZ_Series[i].pIR) / XYZ_Series[i].pCond + 1.0 / XYZ_Series[i].fluidAnn.hc);
            }
            B1 = XYZ_Series[i].fluidPipe.flDens * XYZ_Series[i].fluidPipe.flCp * XYZ_Series[i].pOR / (2.0 * Uap);
            B2 = -h.Q * XYZ_Series[i].fluidPipe.flDens * XYZ_Series[i].fluidPipe.flCp / (2.0 * PI * XYZ_Series[i].pOR * Uap);

            double Cp1, Cp2, Cp3, Cp4;
            Cp1 = 1.0 / B1;
            Cp2 = -B2 * h.dt / ds;
            Cp3 = B1 + B2 * h.dt / ds - h.dt;
            Cp4 = h.dt;

            // check if curt Q in is TOO Giant
            if (Cp3 < 0.0)
            {
                Cp2 = B1 - h.dt;
                Cp3 = 0.0;
            }

            Tpipe[i] = Cp1 * (Cp2 * Tpipe[i-1] + Cp3 * Tpipe[i] + Cp4 * Tannulus[i]);
           // std::cout << i << ", " << Tp(i, n1) << std::endl;
        }

        /**************************************************************************
        * Description: Formula of calculating annulus fluid temperature profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/
        // boundary condition (at total depth, Tp = Ta)
        Tannulus[nz - 1] = Tpipe[nz - 1];

        // main profile
        for (int i = nz - 2; i >= 0; --i)
        {
            rw = XYZ_Series[i].d / 2;
            ds = XYZ_Series[i + 1].md - XYZ_Series[i].md;

            double A1, A2, A3, A4;
            //20201011DEBUG via kxpt@me.com
            // overall heat transfer coefficient between drillpipe and annulus fluid
            double Uap = XYZ_Series[i].fluidAnn.hc;
            if (XYZ_Series[i].pOR > 0.0)
            {
                Uap = 1.0 / (XYZ_Series[i].pOR / (XYZ_Series[i].pIR * XYZ_Series[i].fluidPipe.hc) + XYZ_Series[i].pOR * log(XYZ_Series[i].pOR / XYZ_Series[i].pIR) / XYZ_Series[i].pCond + 1.0 / XYZ_Series[i].fluidAnn.hc);
            }
            A1 = XYZ_Series[i].fluidAnn.flDens * XYZ_Series[i].fluidAnn.flCp * (pow(rw, 2) - pow(XYZ_Series[i].pOR, 2)) / (2.0 * rw * XYZ_Series[i].fluidAnn.hc);
            A2 = h.Q * XYZ_Series[i].fluidAnn.flDens * XYZ_Series[i].fluidAnn.flCp / (2.0 * PI * rw * XYZ_Series[i].fluidAnn.hc);
            A3 = XYZ_Series[i].pOR * Uap / (rw * XYZ_Series[i].fluidAnn.hc);
            A4 = qs[i] / (2 * PI * rw * XYZ_Series[i].fluidAnn.hc * ds);


            double Ca1, Ca2, Ca3, Ca4, Ca5, Ca6;
            Ca1 = 1.0 / A1;
            Ca2 = A1 - A2 * h.dt / ds - A3 * h.dt - h.dt;
            Ca3 = A2 * h.dt / ds;
            Ca4 = A3 * h.dt;
            Ca5 = h.dt;
            Ca6 = A4 * h.dt;

            // check if curt Q in is TOO Giant
            if (Ca2 < 0.0)
            {
                Ca3 = A1 - A3 * h.dt - h.dt;
                Ca2 = 0.0;
            }
            Tannulus[i] = Ca1 * (Ca2 * Tannulus[i]+ Ca3 * Tannulus[i+1] + Ca4 * Tpipe[i] + Ca5 * Tformation[i][0] + Ca6);
           // std::cout << i << ", " << Ta(i, n1) << std::endl;

        }

        /**************************************************************************
        * Description: Formula of calculating formation temperature profile.
        * Ref: Master's thesis of Duc A. Nguyen.
        * Equ: 4.1.
        **************************************************************************/

        // boundary condition at surface
        // formation temperature node at surface and wellbore wall
        double Cf1, Cf2, Cf3, Cf4, Cf5;
        Cf1 = 4.0 * h.dt / (h.dr * ds * XYZ_Series[0].formInfo[0]->fDens * XYZ_Series[0].formInfo[0]->fCp);
        Cf2 = h.dr * ds * XYZ_Series[0].formInfo[0]->fDens * XYZ_Series[0].formInfo[0]->fCp / 
            (4.0 * h.dt) - h.dr * h.surfHTC / 2.0 - ds * XYZ_Series[0].formInfo[0]->fCond / h.dr - 
            h.dr * XYZ_Series[0].formInfo[0]->fCond / (2.0 * ds);
        Cf3 = ds * XYZ_Series[0].formInfo[0]->fCond / (2.0 * h.dr);
        Cf4 = h.dr * XYZ_Series[0].formInfo[0]->fCond / (2.0 * ds);
        Cf5 = h.dr * h.surfHTC / 2.0;

        //Tf(0, 0, n1) = Cf1 * (Cf2 * Tf(0, 0, n0) + Cf3 * (Tf(0, 1, n0) + Ta(0, n0)) + Cf4 * Tf(1, 0, n0) + Cf5 * h.surfTemp);
        //Tf(0, n1) = Cf1 * (Cf2 * Tf(0, n0) + Cf3 * (Tf(0, n0) + Ta(0, n0)) + Cf4 * Tf(1, n0) + Cf5 * h.surfTemp);
        Tformation[0][0]= Cf1 * (Cf2 * Tformation[0][0] + Cf3 * (Tformation[0][0] + Tannulus[0]) + Cf4 * Tformation[1][0] + Cf5 * h.surfTemp);

        // main profile at surface
        nr = Ppore[0].size();
        for (int j = 1; j < nr - 1; ++j)
        {
            double Cf1, Cf2, Cf3, Cf4, Cf5, Cf6;
            fmaIndex = 0;
            while (fmaIndex < XYZ_Series[0].formInfo.size() - 1)
            {
                if (Radius[0][j] > XYZ_Series[0].formInfo[fmaIndex + 1]->innerRadius)
                {
                    fmaIndex++;
                }
            }
            Cf1 = 2.0 * h.dt / (h.dr * ds * XYZ_Series[0].formInfo[fmaIndex]->fDens * XYZ_Series[0].formInfo[fmaIndex]->fCp);
            Cf2 = h.dr * ds * XYZ_Series[0].formInfo[fmaIndex]->fDens * XYZ_Series[0].formInfo[fmaIndex]->fCp / (2.0 * h.dt) - pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * h.surfHTC / 2.0
                - pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * ds) - ds * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * h.dr) * (1.0 / pow(h.eps, j - 1) + 1.0 / pow(h.eps, j));
            Cf3 = ds * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * pow(h.eps, j - 1) * h.dr);
            Cf4 = ds * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * pow(h.eps, j) * h.dr);
            Cf5 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[0].formInfo[fmaIndex]->fCond / (2.0 * ds);
            Cf6 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * h.surfHTC / 2.0;

            //Tf(0, j) = Cf1 * (Cf2 * Tf(0, j) + Cf3 * Tf(0, j - 1) + Cf4 * Tf(0, j + 1) + Cf5 * Tf(1, j) + Cf6 * h.surfTemp);
            Tformation[0][j] = Cf1 * (Cf2 * Tformation[0][j] + Cf3 * Tformation[0][j-1] + Cf4 * Tformation[0][j+1] + Cf5 * Tformation[1][j] + Cf6 * h.surfTemp);
        }

        // formation temperature node at surface and far field
        Tformation[0][nr - 1] = Tformation[0][nr - 2];
        
        //--------------------------------------------------------------------//

        // main profile
        for (int i = 1; i < nz - 1; ++i)
        {
            // boundary condition at borehole wall
            double Cf1, Cf2, Cf3, Cf4, Cf5;
            Cf1 = 2.0 * h.dt / (h.dr * ds * XYZ_Series[i].formInfo[0]->fDens * XYZ_Series[i].formInfo[0]->fCp);
            Cf2 = h.dr * ds * XYZ_Series[i].formInfo[0]->fDens * XYZ_Series[i].formInfo[0]->fCp / (2.0 * h.dt) - 
                ds * XYZ_Series[i].fluidAnn.hc - ds * XYZ_Series[i].formInfo[0]->fCond / h.dr - h.dr * XYZ_Series[i].formInfo[0]->fCond / ds;
            Cf3 = h.dr * XYZ_Series[i].formInfo[0]->fCond / (2.0 * ds);
            Cf4 = ds * XYZ_Series[i].formInfo[0]->fCond / h.dr;
            Cf5 = ds * XYZ_Series[i].fluidAnn.hc;

            Tformation[i][0] = Cf1 * (Cf2 * Tformation[i][0] + Cf3 * (Tformation[i-1][0] + Tformation[i + 1][0]) + Cf4 * Tformation[i][1] + Cf5 * Tannulus[i]);

            // main profile
            rw = XYZ_Series[i].d / 2;
            if (i == 0)
                ds = XYZ_Series[1].md - XYZ_Series[0].md;
            else
                ds = XYZ_Series[i].md - XYZ_Series[i - 1].md;

            nr = Ppore[i].size();

            for (int j = 1; j < nr - 1; ++j)
            {
                double eps1;
                if (fabs(h.eps - 1.0) <= TOL)
                {
                    eps1 = j;
                }                    
                else
                {
                    eps1 = (1.0 - pow(h.eps, j)) / (1.0 - h.eps);
                }
                   
                fmaIndex = 0;
                while (fmaIndex < XYZ_Series[i].formInfo.size() - 1)
                {
                    if (Radius[i][j] > XYZ_Series[i].formInfo[fmaIndex + 1]->innerRadius)
                    {
                        fmaIndex++;
                    }

                }
                //20201011 DEBUG via kxpt@me.com
                double alphaf = XYZ_Series[i].formInfo[fmaIndex]->fCond / (XYZ_Series[i].formInfo[fmaIndex]->fDens * XYZ_Series[i].formInfo[fmaIndex]->fCp); // formation thermal diffusivity
                double Cf1, Cf2, Cf3, Cf4, Cf5, Cf6, Cf7;
                Cf1 = alphaf * h.dt / pow(h.dr, 2);
                Cf2 = 1.0 / pow(h.eps, 2 * j - 2) + (1.0 - h.eps) / (pow(h.eps, 2 * j - 1) * (1.0 + h.eps))
                    - 1.0 / (((rw / h.dr) + eps1) * (1.0 + h.eps) * pow(h.eps, j - 1));
                Cf3 = pow(h.dr, 2) / (alphaf * h.dt) - (1.0 + pow(h.eps, 2)) / pow(h.eps, 2 * j) - 2 * pow(h.dr, 2) / pow(ds, 2);
                Cf4 = 1.0 / pow(h.eps, 2 * j) - (1.0 - h.eps) / (pow(h.eps, 2 * j - 1) * (1.0 + h.eps))
                    + 1.0 / (((rw / h.dr) + eps1) * (1.0 + h.eps) * pow(h.eps, j - 1));
                Cf5 = pow(h.dr / ds, 2);
                Cf6 = pow(h.dr / ds, 2);
                Cf7 = (XYZ_Series[i].formInfo[fmaIndex]->pflDens * XYZ_Series[i].formInfo[fmaIndex]->pflCp / (XYZ_Series[i].formInfo[fmaIndex]->fDens *
                    XYZ_Series[i].formInfo[fmaIndex]->fCp) * XYZ_Series[i].formInfo[fmaIndex]->fPerm / (XYZ_Series[i].formInfo[fmaIndex]->pflVisc * XYZ_Series[i].formInfo[fmaIndex]->fPor))
                    / (alphaf * pow(1.0 + h.eps, 2) * pow(h.eps, 2 * j - 2));

                Tformation[i][j] = Cf1 * (Cf2 * Tformation[i][j-1] + Cf3 * Tformation[i][j] + Cf4 * Tformation[i][j+1]
                    + Cf5 * Tformation[i-1][j] + Cf6 * Tformation[i+1][j])
                    + Cf7 * (Ppore[i][j + 1] - Ppore[i][j - 1]) * (Tformation[i][j+1] - Tformation[i][j-1]);
            }

            // boundary condition at far field
            Tformation[i][nr - 1] = Tformation[i][nr - 2];
        }

        //--------------------------------------------------------------------//

        // boundary condition at bottomhole
        // formation temperature node at bottomhole and wellbore wall
        //double Tfbh = h.surfTemp + XYZ_Series[nz - 1].formInfo[0]->fThermal * XYZ_Series[nz - 1].z; // not really accurate, should use drill ahead TVD
        double Tfbh = XYZ_Series[nz - 1].formInfo[0]->fTemp;

        // double Cf1, Cf2, Cf3, Cf4, Cf5;
        Cf1 = 4.0 * h.dt / (h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp);
        Cf2 = h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp / (4.0 * h.dt) - 
            ds * XYZ_Series[nz - 1].fluidAnn.hc / 2.0 - ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * h.dr) - h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / ds;
        Cf3 = h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * ds);
        Cf4 = ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * h.dr);
        Cf5 = ds * XYZ_Series[nz - 1].fluidAnn.hc / 2.0;

        Tformation[nz - 1][0] = Cf1 * (Cf2 * Tformation[nz - 1][0] + Cf3 * (Tformation[nz - 2][0] + Tfbh) + Cf4 * Tformation[nz - 1][0] + Cf5 * Tannulus[nz - 1]);

        
        // main profile at bottomhole
        nr = Ppore.back().size();

        for (int j = 1; j < nr - 1; ++j)
        {
            double Cf1, Cf2, Cf3, Cf4, Cf5, Cf6;
            Cf1 = 2.0 * h.dt / (h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp);
            Cf2 = h.dr * ds * XYZ_Series[nz - 1].formInfo[0]->fDens * XYZ_Series[nz - 1].formInfo[0]->fCp / (2.0 * h.dt) - pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / ds
                - ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * h.dr) * (1.0 / pow(h.eps, j - 1) + 1.0 / pow(h.eps, j));
            Cf3 = ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * pow(h.eps, j - 1) * h.dr);
            Cf4 = ds * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * pow(h.eps, j) * h.dr);
            Cf5 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * ds);
            Cf6 = pow(h.eps, j - 1) * (1.0 + h.eps) * h.dr * XYZ_Series[nz - 1].formInfo[0]->fCond / (2.0 * ds);

            Tformation[nz - 1][j] = Cf1 * (Cf2 * Tformation[nz - 1][j] + Cf3 * Tformation[nz - 1][j-1] + Cf4 * Tformation[nz - 1][j+1] + Cf5 * Tformation[nz - 2][j] + Cf6 * Tfbh);
        }

        // formation temperature node at bottomhole and far field
        Tformation[nz - 1][nr - 1] = Tformation[nz - 1][nr - 2];
}

/**************************************************************************
* Description: Formula of evaluation of frictional heat sources.
* Ref: Master's thesis of Duc A. Nguyen.
* Equ: 2.55- 2.57.
**************************************************************************/
std::vector<double> HeatTransfer::HeatByDragForce(const VarList& h)
{
    const double PI = 3.14159265358979;
    const double TOL = 1.0e-8;

    std::vector<double> qd;

    int tem = 0;
    for (std::vector<DragTorqueData>::const_iterator i = DT_Series.begin(); (i + 1) != DT_Series.end(); ++i, ++tem)
    {
        double ds = (i + 1)->md - i->md;
        double qs;
        //First determine whether there is a drill string at the current step
        if (XYZ_Series[tem].pOR > 0.0)
        {
            if (h.RPM <= TOL) // sliding mode
            {
                qs = h.mu * i->Wc * h.ROP * ds;
            }
            else // rotating mode
            {
                qs = h.mu * i->Wc * XYZ_Series[tem].pOR * 2.0 * PI * h.RPM * ds;
            }
        }
        else
        {
            qs = 0.0;
        }
        //这不是没考虑该项热源项嘛？ 2023-07-23
        qs = 0.0; //temperaturaly ingore pipe frictions
        if (std::isnormal(qs))
        {
            qd.push_back(qs);
        }
        else
        {
            qd.push_back(0.0);
        }
    }

    return qd;
}

double HeatTransfer::HeatByDrillbit(const VarList& h)
{
    const double PI = 3.14159265358979;
    double qb = (1.0 - h.bitEff) * (h.WOB * h.ROP + 2.0 * PI * h.RPM * DT_Series.back().Mt);
    qb = std::max(0.0, qb);
    if (std::isinf(qb) || std::isnan(qb))
    {
        qb = 0.0;
    }
    return qb;
}
```







### **head：**

```c++
#include "Temperature/WellboreHeatTransfer.h"
#include <cmath>
#include <algorithm> // for swap() function
#include <functional>
#include"libInterpolate/Interpolate.hpp"
```

#include"libInterpolate/Interpolate.hpp":是一个仅限 C++ 头文件的库，旨在实现高效、轻松的数据插值。
`libInterpolate` is a C++ header-only library designed for efficient and easy interpolation of data. The code snippet provided:

```cpp
#include "libInterpolate/Interpolate.hpp"
```

is including the `libInterpolate` header file into a C++ project, allowing access to its interpolation features. Here's a breakdown of its significance and how it is typically used:

### Purpose of the Library:
`libInterpolate` provides various interpolation methods that can be applied to discrete data points. Interpolation is a process of estimating unknown values that fall within the range of a discrete set of known data points. Common applications include numerical analysis, scientific computing, and any domain where approximating values between known data is necessary.

### Available Interpolation Methods:
The library includes a variety of interpolation techniques, such as:
1. **Linear Interpolation:** Straight-line interpolation between known data points.
2. **Polynomial Interpolation:** Fits a polynomial curve through the points.
3. **Spline Interpolation:** More advanced, providing smooth curves that better fit the data (e.g., cubic spline).
4. **Barycentric Interpolation:** A method of polynomial interpolation that is efficient and stable.

### Example Usage:

An example of how `libInterpolate` can be used is shown below:

```cpp
#include "libInterpolate/Interpolate.hpp"
#include <vector>
#include <iostream>

int main() {
    std::vector<double> xData = {0.0, 1.0, 2.0, 3.0};  // Known x-values
    std::vector<double> yData = {0.0, 1.0, 4.0, 9.0};  // Known y-values (y = x^2)

    // Create an interpolator instance
    _1D::LinearInterpolator<double> interp;

    // Set the data for interpolation
    interp.setData(xData, yData);

    // Perform interpolation
    double y = interp(1.5);  // Interpolates at x = 1.5

    std::cout << "Interpolated value at x=1.5: " << y << std::endl;

    return 0;
}
```

### Key Features:
- **Header-only:** This means no need to link against a compiled library; you only need the header files.
- **Templated:** Works with various data types (e.g., `double`, `float`).
- **1D Interpolation:** The library is optimized for one-dimensional interpolation, which is the most common use case.

### Conclusion:
By including `libInterpolate/Interpolate.hpp`, you gain access to efficient interpolation methods in your C++ program, making it easier to estimate intermediate values between known data points. You would typically use this library in applications where smooth transitions between data points are critical, such as simulations, numerical methods, and data analysis tasks.

```c++
void HeatTransfer::TemperatureResultsRemapping(const VarList& h, const std::vector<double>& preMD,
    const std::vector<double>& preTp, const std::vector<double>& preTa, const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, const std::vector<std::vector<double>>& prePpore)
//温度结果重新映射TemperatureResultsRemapping



{
    Radius.clear();
    Ppore.clear();
    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
    size_t nz = preTf.size();
    Radius = preRadius;

     try
     {
        // STEP2: pore pressure profile.
       // Ppore = prePpore;
        // STEP3:
        // if previous heat profile "NOT" valid.
        if (preTp.size() < 1 || preTa.size() != preTf.size())
        {
            for (int i = 0; i < nz; ++i)
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        +std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }
                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                std::vector<double> Tf_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                    Tf_.push_back(tmp);
                Tformation.push_back(Tf_);
                // std::cout << "check line 104, indx i: " << i << "\t currMD: " << XYZ_Series[i].md << " \tTp:" << Tp(i, 0) << "\tsTa: " << Ta(i, 0) << "\tsTf: " << Tf(i, 0) << std::endl;
            }
        }

        // STEP 4:
        // else previous heat profile "IS" valid.
        // if previous Tp profile contian -999.25, means tripping in
        // use annulus's temperature replace of pipe's component.
        std::vector<double> perTp_refr; // refreshed perTp profile
        for (size_t i = 0; i < preTp.size(); i++)
        {
            if (preTp[i] < 0)
                perTp_refr.push_back(preTa[i]);
            else
                perTp_refr.push_back(preTp[i]);
        }
        // STEP 5:
        double curtMD;
        int tmp = 0;

        _2D::BilinearInterpolator<double> interp2DTf;
        _2D::BilinearInterpolator<double> interp2DPp;

        //construct 2D interploation data format
        std::vector<double> preMD2D;
        std::vector<double> preRadius2D;
        std::vector<double> preTf2D;
        std::vector<double> prePore2D;
        for (int i=0;i<preMD.size();i++)
        {
            for (int j=0;j<preRadius[i].size();j++)
            {
                preMD2D.push_back(preMD[i]);
                preRadius2D.push_back(preRadius[i][j]);
                preTf2D.push_back(preTf[i][j]);
                prePore2D.push_back(prePpore[i][j]);
            }
        }
        interp2DTf.setData(preMD2D, preRadius2D, preTf2D);
        interp2DPp.setData(preMD2D, preRadius2D, prePore2D);


        for (size_t i = 0; i < XYZ_Series.size(); i++)
        {
            curtMD = XYZ_Series[i].md;

            // 1. case: current well component "BEFORE" previous' component
            if (curtMD < preMD.front())
            {
                Tpipe.push_back(perTp_refr.front());
                Tannulus.push_back(preTa.front());

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    double curtR = Radius[i][j];
                    if (curtR < preRadius[0].front())
                    {
                        Tf_.push_back(preTf[0].front());
                        Pp_.push_back(prePpore[0].front());
                    }
                    else if (curtR > preRadius[0].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp < -273)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                    }
                    else
                    {
                        Tf_.push_back(linerInterpolation4Vector(curtR, preRadius[0], preTf[0]));
                        Pp_.push_back(linerInterpolation4Vector(curtR, preRadius[0], prePpore[0]));
                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
            // 2. case: current well component "AFTER" previous' component
            else if (curtMD > preMD.back())
            {
                // get far field property.
                //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                if (tmp < -273)
                {
                    std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                        + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                    throw(std::runtime_error(err));
                }

                Tpipe.push_back(tmp);
                Tannulus.push_back(tmp);

                // set current formation's temperature profile
                std::vector<double> Tf_;
                std::vector<double> Pp_;

                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                    Tf_.push_back(tmp);
                    Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);
                }
                  
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);

            }
            // 3. case: current well component "BELONG TO" previous' component
            else
            {
                Tpipe.push_back(linerInterpolation4Vector(curtMD, preMD, perTp_refr));
                Tannulus.push_back(linerInterpolation4Vector(curtMD, preMD, preTa));

                // 3.a. set "preIndx" and suitale radius/ Tf profile
                // note: first, need set prevoius formation temperature profile to current compoent
                // then, special for curtR

                std::vector<double> Tf_;
                std::vector<double> Pp_;
                for (size_t j = 0; j < Radius[i].size(); j++)
                {
                   // std::cout << i << ", " << j << std::endl;

                    double curtR = Radius[i][j];
                    if (curtR < preRadius[i].front())
                    {
                        Tf_.push_back(preTf[i].front());
                        Pp_.push_back(prePpore[i].front());
                    }
                    else if (curtR > preRadius[i].back())
                    {
                        // get far field property.
                        //double tmp = h.surfTemp + XYZ_Series[i].formInfo.back()->fTemp * XYZ_Series[i].z;
                        double tmp = XYZ_Series[i].formInfo.back()->fTemp;
                        if (tmp <-273.00)
                        {
                            std::string err = "Formation temperature error in TemperatureResultsRemapping: "
                                + std::to_string(XYZ_Series[i].formInfo.back()->fTemp);
                            throw(std::runtime_error(err));
                        }
                        Tf_.push_back(tmp);
                        Pp_.push_back(XYZ_Series[i].formInfo.back()->Ppore);

                    }
                    else
                    {
                        Tf_.push_back(interp2DTf(curtMD, curtR));
                        Pp_.push_back(interp2DPp(curtMD, curtR));

                    }
                }
                Tformation.push_back(Tf_);
                Ppore.push_back(Pp_);
            }
        }
       // std::cout << "tmp end: " << tmp << std::endl;
    }
    catch (const std::exception& e)
    {
        std::string error = e.what() + std::string(" in temperature Results Remapping, in Heat Transfer Cal");
        throw std::runtime_error(error);
    }
}
```







这段代码定义了 `HeatTransfer` 类的一个成员函数 `TemperatureResultsRemapping`，其功能是根据输入的多组数据（如测深、温度、孔隙压力等）对温度计算结果进行重新映射或处理。接下来对该函数的语法结构和内容进行详细解析：

### 函数签名

```cpp
void HeatTransfer::TemperatureResultsRemapping(
    const VarList& h, 
    const std::vector<double>& preMD,
    const std::vector<double>& preTp, 
    const std::vector<double>& preTa, 
    const std::vector<std::vector<double>>& preRadius,
    const std::vector<std::vector<double>>& preTf, 
    const std::vector<std::vector<double>>& prePpore)
```

1. **返回类型 (`void`)**: 
   - 该函数没有返回值，表示函数执行时只做一些操作，不需要返回数据给调用者。

2. **`HeatTransfer::TemperatureResultsRemapping`**:
   - **类名`HeatTransfer`**: 表示这是 `HeatTransfer` 类中的一个成员函数。
   - **`TemperatureResultsRemapping`**: 函数名，说明这个函数负责“重新映射”温度结果（即可能是对已有的温度结果进行修正、调整等）。

3. **参数列表**:
   - **`const VarList& h`**: `VarList` 是一种类型（可能是用户自定义的类型），通过引用传递，而且是 `const`，意味着函数不会修改 `h` 的内容。
   - **`const std::vector<double>& preMD`**: 传递的是一维 `double` 类型的 `std::vector`，用于存储“测深”数据（或其他相关数据）。`const` 表明 `preMD` 不会在函数内被修改，且通过引用传递提高效率。
   - **`const std::vector<double>& preTp`**: 传递的是一维 `std::vector`，可能用于存储管道的温度数据（Tp 可以解释为 Pipe Temperature）。
   - **`const std::vector<double>& preTa`**: 传递的是一维 `std::vector`，可能用于存储环空的温度数据（Ta 可以解释为 Annulus Temperature）。
   - **`const std::vector<std::vector<double>>& preRadius`**: 传递的是二维 `std::vector`，可能用于存储不同层级的半径数据。二维向量常用于存储不同深度或位置的多组值。
   - **`const std::vector<std::vector<double>>& preTf`**: 传递的是二维 `std::vector`，可能用于存储形成温度数据（Tf 可以解释为 Formation Temperature）。
   - **`const std::vector<std::vector<double>>& prePpore`**: 传递的是二维 `std::vector`，可能用于存储不同深度的孔隙压力数据（Ppore 可以解释为 Pore Pressure）。

### 函数体解析

```cpp
{
    Radius.clear();
    Ppore.clear();
    Tpipe.clear();
    Tannulus.clear();
    Tformation.clear();
}
```

1. **`Radius.clear();`**:
   - `Radius` 是类中的成员变量，用于存储半径数据。这里调用 `clear()` 函数清除之前的数据，确保接下来重新赋值时数据是干净的。
   
2. **`Ppore.clear();`**:
   - 同样，清除类中用于存储孔隙压力数据的成员变量 `Ppore`。

3. **`Tpipe.clear(); Tannulus.clear(); Tformation.clear();`**:
   - 分别清空存储管道温度（`Tpipe`）、环空温度（`Tannulus`）和形成温度（`Tformation`）的类成员变量。这样可以保证在函数内进行数据重新映射时，原有数据不会影响新的计算。

### 拷贝数据

```cpp
size_t nz = preTf.size();
Radius = preRadius;
```

1. **`size_t nz = preTf.size();`**:
   - `nz` 是用来存储 `preTf` 的大小（即第一维的长度），`preTf` 是一个二维数组，这里通过 `.size()` 获取数组的大小。
   - `size_t` 是无符号整型，通常用于表示容器的大小，因为它可以确保不会出现负值。

2. **`Radius = preRadius;`**:
   - 这行代码将输入的 `preRadius` 赋值给类成员变量 `Radius`。注意，这里是直接赋值，而不是通过循环逐一赋值。`std::vector` 支持直接赋值操作，`Radius` 和 `preRadius` 都是 `std::vector<std::vector<double>>` 类型，因此这种赋值操作有效。

### 可能的函数扩展
虽然现在只进行了数据清空和简单的赋值，后续代码很可能包括更多复杂的计算或数据处理操作，比如对温度和压力的重映射。通过 `nz`（前面定义的 `preTf` 的大小），可以推测后续可能会根据数据的深度维度来处理不同层级的温度和压力数据。

### 小结

- 该函数的主要功能是接收若干预先计算好的温度、半径和压力数据，首先清空现有的数据成员变量，然后对数据进行赋值和可能的后续处理。
- 语法上使用了 `std::vector` 进行动态数组操作，并通过 `clear()` 清空数据，确保在处理新数据时不会受到旧数据的干扰。

